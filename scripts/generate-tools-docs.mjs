import fs from 'fs';
import path from 'path';

const TOOLS_DIR = path.join(process.cwd(), 'docs-src', 'tools');
const SOURCES_FILE = path.join(TOOLS_DIR, 'sources.txt');
const GEN_DIR = path.join(TOOLS_DIR, 'generated');
const RSPRESS_GEN_DIR = path.join(process.cwd(), '.rspress');
const SIDEBAR_OUTPUT_PATH = path.join(RSPRESS_GEN_DIR, 'tools-sidebar.ts');

// --- Helper Functions ---

function parseMetadata(content) {
  const metadata = {};
  const commentMatch = content.match(/<!--\s*([\s\S]*?)\s*-->/);
  if (commentMatch) {
    const metadataLines = commentMatch[1].trim().split('\n');
    for (const line of metadataLines) {
      const match = line.match(/(\w+):\s*(.*)/);
      if (match) {
        metadata[match[1].trim()] = match[2].trim();
      }
    }
  }
  return metadata;
}

function extractMainContent(content) {
  return content.replace(/<!--\s*([\s\S]*?)\s*-->/, '').trim();
}


// --- Main Logic ---

async function main() {
  console.log('Starting Tools documentation generation...');

  if (!fs.existsSync(SOURCES_FILE)) {
    console.log('No sources.txt file found. Skipping tools generation.');
    fs.writeFileSync(SIDEBAR_OUTPUT_PATH, 'export const toolsSidebar = [];');
    return;
  }

  if (!fs.existsSync(GEN_DIR)) {
    fs.mkdirSync(GEN_DIR, { recursive: true });
  }
  if (!fs.existsSync(RSPRESS_GEN_DIR)) {
    fs.mkdirSync(RSPRESS_GEN_DIR, { recursive: true });
  }

  const urls = fs.readFileSync(SOURCES_FILE, 'utf-8').split('\n').filter(Boolean);
  const toolPages = [];
  const toolsData = [];

  for (const url of urls) {
    try {
      console.log(`Fetching: ${url}`);
      const response = await fetch(url);
      if (!response.ok) {
        console.error(`[ERROR] Failed to fetch ${url}: ${response.statusText}`);
        continue;
      }
      const rawContent = await response.text();
      const metadata = parseMetadata(rawContent);
      const mainContent = extractMainContent(rawContent);

      if (!metadata.name) {
        console.error(`[ERROR] Could not parse "name" from ${url}. Skipping.`);
        continue;
      }

      const toolName = metadata.name;
      const generatedFileName = `${toolName}.md`;
      const generatedFilePath = path.join(GEN_DIR, generatedFileName);

      // Ensure the directory for the file exists before writing
      fs.mkdirSync(path.dirname(generatedFilePath), { recursive: true });

      const pageContent = mainContent;
      fs.writeFileSync(generatedFilePath, pageContent);
      console.log(`[SUCCESS] Generated page for ${toolName}`);

      const toolLink = `/tools/generated/${toolName}`;
      toolPages.push({
        text: toolName,
        link: toolLink,
      });
      toolsData.push({ ...metadata, link: toolLink });

    } catch (error) {
      console.error(`[ERROR] An error occurred while processing ${url}:`, error);
    }
  }

  // --- Index Page Generation ---
  let indexContent = '# Tools\n\n';
  indexContent += '| Tool | Version | Description | Repository |\n';
  indexContent += '| --- | --- | --- | --- |\n';
  toolsData.forEach(tool => {
    const toolName = `[${tool.name}](${tool.link})`;
    const version = tool.version || '';
    const description = tool.description || '';
    const gitUrl = tool.giturl ? `[GitHub](${tool.giturl})` : '';
    indexContent += `| ${toolName} | ${version} | ${description} | ${gitUrl} |\n`;
  });
  fs.writeFileSync(path.join(TOOLS_DIR, 'index.md'), indexContent);
  console.log(`[SUCCESS] Generated index page at ${path.join(TOOLS_DIR, 'index.md')}`);

  // --- Sidebar Generation ---
  const sidebarItems = [
    {
      text: 'Tools',
      link: '/tools/'
    },
    ...toolPages.map(page => ({
      text: page.text,
      link: page.link
    }))
  ];

  const sidebarContent = `// This file is auto-generated by scripts/generate-tools-docs.mjs\n// Do not edit this file directly.\n\nexport const toolsSidebar = ${JSON.stringify(sidebarItems, null, 2)};\n`;

  fs.writeFileSync(SIDEBAR_OUTPUT_PATH, sidebarContent);
  console.log(`[SUCCESS] Generated sidebar at ${SIDEBAR_OUTPUT_PATH}`);

  console.log('Tools documentation generation complete.');
}

main().catch(console.error);

