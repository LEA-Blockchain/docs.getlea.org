import fs from 'fs';
import path from 'path';

const MODULES_DIR = path.join(process.cwd(), 'docs-src', 'npm-module');
const SOURCES_FILE = path.join(MODULES_DIR, 'sources.txt');
const GEN_DIR = path.join(MODULES_DIR, 'generated');
const RSPRESS_GEN_DIR = path.join(process.cwd(), '.rspress');
const SIDEBAR_OUTPUT_PATH = path.join(RSPRESS_GEN_DIR, 'npm-sidebar.ts');

// --- Helper Functions ---

function parseMetadata(content) {
  const metadata = {};
  const lines = content.split('\n');
  let inMetadataSection = false;

  for (const line of lines) {
    if (line.trim() === '## Metadata') {
      inMetadataSection = true;
      continue;
    }
    if (inMetadataSection) {
      const match = line.match(/-   \*\*(.*?)\*\*:\s(.*)$/);
      if (match) {
        const key = match[1].trim().toLowerCase();
        let value = match[2].trim();
        if (value.startsWith('`') && value.endsWith('`')) {
          value = value.slice(1, -1);
        }
        metadata[key] = value;
      }
    }
  }
  return metadata;
}

function extractMainContent(content) {
  return content.split('## Metadata')[0].trim();
}


// --- Main Logic ---

async function main() {
  console.log('Starting NPM Modules documentation generation...');

  if (!fs.existsSync(SOURCES_FILE)) {
    console.log('No sources.txt file found. Skipping NPM modules generation.');
    fs.writeFileSync(SIDEBAR_OUTPUT_PATH, 'export const npmSidebar = [];');
    return;
  }

  if (!fs.existsSync(GEN_DIR)) {
    fs.mkdirSync(GEN_DIR, { recursive: true });
  }
  if (!fs.existsSync(RSPRESS_GEN_DIR)) {
    fs.mkdirSync(RSPRESS_GEN_DIR, { recursive: true });
  }

  const urls = fs.readFileSync(SOURCES_FILE, 'utf-8').split('\n').filter(line => !line.startsWith('#') && line.trim() !== '');
  const modulePages = [];

  for (const url of urls) {
    try {
      console.log(`Fetching: ${url}`);
      const response = await fetch(url);
      if (!response.ok) {
        console.error(`[ERROR] Failed to fetch ${url}: ${response.statusText}`);
        continue;
      }
      const rawContent = await response.text();
      const metadata = parseMetadata(rawContent);
      const mainContent = extractMainContent(rawContent);

      if (!metadata.name) {
        console.error(`[ERROR] Could not parse "Name" from ${url}. Skipping.`);
        continue;
      }

      const moduleName = metadata.name;
      const generatedFileName = `${moduleName}.md`;
      const generatedFilePath = path.join(GEN_DIR, generatedFileName);

      const pageContent = `# ${moduleName}\n\n${metadata.description || ''}\n\n${mainContent}`;
      fs.writeFileSync(generatedFilePath, pageContent);
      console.log(`[SUCCESS] Generated page for ${moduleName}`);

      modulePages.push({
        text: moduleName,
        link: `/npm-module/generated/${moduleName}`,
        category: metadata.category || 'Miscellaneous',
      });

    } catch (error) {
      console.error(`[ERROR] An error occurred while processing ${url}:`, error);
    }
  }

  // --- Sidebar Generation ---
  const categories = {};
  modulePages.forEach(page => {
    if (!categories[page.category]) {
      categories[page.category] = [];
    }
    categories[page.category].push({
      text: page.text,
      link: page.link,
    });
  });

  const categoryItems = Object.entries(categories).map(([categoryName, items]) => ({
    text: categoryName,
    collapsible: true,
    collapsed: false,
    items: items,
  }));

  const sidebarItems = [
    {
      text: 'NPM Modules',
      link: '/npm-module/'
    },
    ...categoryItems
  ];

  const sidebarContent = `// This file is auto-generated by scripts/generate-npm-docs.mjs\n// Do not edit this file directly.\n\nexport const npmSidebar = ${JSON.stringify(sidebarItems, null, 2)};\n`;

  fs.writeFileSync(SIDEBAR_OUTPUT_PATH, sidebarContent);
  console.log(`[SUCCESS] Generated sidebar at ${SIDEBAR_OUTPUT_PATH}`);

  console.log('NPM Modules documentation generation complete.');
}

main().catch(console.error);
