[{"id":0,"title":"Development","content":"#\n\nLearn about the Node API, Smart Contract Development, and the SDK.","routePath":"/development/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"Markdown & MDX","content":"#\n\nRspress supports not only Markdown but also MDX, a powerful way to develop\ncontent.\n\n\nMarkdown#\n\nMDX is a superset of Markdown, which means you can write Markdown files as\nusual. For example:\n\n\n\n\nUse component#\n\nWhen you want to use React components in Markdown files, you should name your\nfiles with .mdx extension. For example:\n\n\n\n\nFront matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode block#\n\n\nBasic usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow line numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/guide/","lang":"","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":88},{"text":"Use component","id":"use-component","depth":2,"charIndex":198},{"text":"Front matter","id":"front-matter","depth":2,"charIndex":336},{"text":"Custom container","id":"custom-container","depth":2,"charIndex":767},{"text":"Code block","id":"code-block","depth":2,"charIndex":1190},{"text":"Basic usage","id":"basic-usage","depth":3,"charIndex":1204},{"text":"Show line numbers","id":"show-line-numbers","depth":3,"charIndex":1332},{"text":"Wrap code","id":"wrap-code","depth":3,"charIndex":1455},{"text":"Line highlighting","id":"line-highlighting","depth":3,"charIndex":1580},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1712}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! üéÅ","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"","content":" * LIP: 1\n * Layer: Core Encoding\n * Title: Extend Tag 10 for Sub-Typed Data (IxData Field)\n * Author: Allwin Ketnawang\n * Created: 2025-04-27\n * Superseded-By: 6\n * Status: Replaced\n\n\nAbstract#\n\nThis LIP proposes replacing the original CTE v1.0 Tag 10 \"Index Reference\" field\nwith a more versatile structure named the \"Index and Extended Data Field\" (or\n\"IxData Field\" for short). This new structure utilizes the previously reserved\nbits 1-0 of the header byte to introduce four sub-types, enabling the efficient\nencoding of: legacy 4-bit indices, standard variable-length integers\n(ULEB128/SLEB128), common fixed-size data types (integers, floats), and\nsingle-byte constants (including booleans). This enhances the expressiveness and\nefficiency of the CTE format.\n\n\nMotivation#\n\nThe original CTE v1.0 specification defined the Tag 10 field solely as a 1-byte\nreference containing a 4-bit index (0-15) into preceding key or signature lists.\nWhile useful, this is limiting. Applications built on CTE often require encoding\nother fundamental data types compactly, such as:\n\n 1. Integers larger than 15 or needing variable-length encoding for efficiency.\n 2. Signed integers.\n 3. Standard fixed-size types like int32, uint64, float, and double without the\n    overhead of the generic Command Data field.\n 4. Atomic boolean values (true/false) or other single-byte markers (like null)\n    in a highly compact, unambiguous way.\n\nThis proposal addresses these needs by repurposing the Tag 10 field. By using\nthe two previously reserved bits (1-0) as a sub-type selector, we can introduce\nmultiple data formats under a single tag, significantly increasing the utility\nand efficiency of the CTE format while maintaining partial backwards\ncompatibility for the original index reference use case.\n\n\nSpecification#\n\nThis LIP replaces Section 4.3 of the CTE v1.0 specification document entirely\nwith the following:\n\n--------------------------------------------------------------------------------\n\n\n4.3. Index and Extended Data Field (IxData Field) (Tag 10)#\n\n * Tag: 10\n * Purpose: Encodes different types of data including simple list indices,\n   variable-length integers using standard encodings, standard fixed-size data\n   types, and single-byte constants or markers.\n * Identification: Fields of this type are identified by the Tag 10 in bits 7-6\n   of the header byte. The specific interpretation and format are determined by\n   the Sub-Type field located in bits 1-0 (SS) of the header byte.\n * General Header Byte Structure:\n   \n   BITS   FIELD             DESCRIPTION\n   7-6    Tag (10)          Identifies this as the IxData Field family.\n   5-2    Sub-Data (XXXX)   4-bit value whose meaning depends on the Sub-Type (SS)\n                            field.\n   1-0    Sub-Type (SS)     Determines the format and interpretation (00, 01, 10, 11).\n\n * Endianness Note: Unless otherwise specified, all multi-byte numerical data\n   within CTE v1.1 fields (including sub-types defined below and Command Data)\n   MUST be encoded using Little-Endian byte order. LEB128 encodings follow their\n   own standard byte order.\n\n--------------------------------------------------------------------------------\n\n4.3.1. Sub-Type 00: Legacy Index Reference#\n\n * Sub-Type Code (SS): 00\n * Purpose: Provides a zero-based index referencing an item within the preceding\n   Public Key List (Section 4.1) or Signature List (Section 4.2). The context\n   determines which list is being referenced. This maintains compatibility with\n   CTE v1.0.\n * Format:\n   * Header Byte: 10 IIII 00\n     \n     BITS   FIELD           DESCRIPTION\n     7-6    Tag (10)        IxData Field family.\n     5-2    Index (IIII)    The 4-bit index value (0-15).\n     1-0    Sub-Type (00)   Specifies Legacy Index Reference format.\n   \n   * Data: No following data bytes.\n * Constraints: The Index value (IIII) MUST correspond to a valid position\n   within the relevant list.\n * Total Size: 1 byte.\n * Reserved Values: None within this sub-type.\n * Example (Reference Index 5): Header Byte: 10 0101 00 = 0x94\n\n--------------------------------------------------------------------------------\n\n4.3.2. Sub-Type 01: Variable-Length Encoded Integer (Varint)#\n\n * Sub-Type Code (SS): 01\n * Purpose: Encodes a signed or unsigned integer value using standard\n   variable-length encoding schemes (LEB128) or represents the value 0 directly.\n * Format:\n   * Header Byte: 10 EEEE 01\n     \n     BITS   FIELD                    DESCRIPTION\n     7-6    Tag (10)                 IxData Field family.\n     5-2    Encoding Scheme (EEEE)   Specifies the encoding method or direct value (see table\n                                     below).\n     1-0    Sub-Type (01)            Specifies Varint format.\n   \n   * Data: For LEB128 schemes, followed by the bytes constituting the\n     variable-length encoded integer according to the relevant standard. The\n     number of data bytes is determined by the LEB128 encoding itself (via\n     continuation bits).\n * Encoding Schemes (EEEE):\n   \n   EEEE (BIN)   EEEE (DEC)   HEADER BYTE (HEX)   ENCODING SCHEME / VALUE   NOTES                                           SIZE (BYTES)\n   0000         0            0x81                Value 0                   Represents the integer value 0 directly.        1 (Header only)\n   0001         1            0x85                ULEB128                   Unsigned LEB128 encoded integer data follows.   1 + Data Length\n   0010         2            0x89                SLEB128                   Signed LEB128 encoded integer data follows.     1 + Data Length\n   0011         3            0x8D                Reserved                  For future variable-length encoding schemes.    -\n   ...          ...          ...                 ...                       (Codes 3-15 are Reserved)                       ...\n   1111         15           0xBD                Reserved                  For future variable-length encoding schemes.    -\n\n * Constraints:\n   * Decoders MUST correctly implement ULEB128 and SLEB128 decoding.\n   * While LEB128 can encode arbitrarily large integers, implementations MAY\n     impose practical limits based on transaction size constraints or\n     application needs (e.g., limiting to 64-bit or 128-bit range).\n * Total Size: 1 byte for value 0; 1 + Length(LEB128 Data) bytes otherwise.\n * Reserved Values: Encoding scheme codes 3 through 15 are reserved.\n * Example 1 (Value 300 / 0x12C using ULEB128):\n   * ULEB128 requires 2 data bytes: 0xAC, 0x02. EEEE = 0001.\n   * Header Byte: 10 0001 01 = 0x85\n   * Following Data: 0xAC, 0x02\n * Example 2 (Value -100 using SLEB128):\n   * SLEB128 requires 2 data bytes: 0x9C, 0x7F. EEEE = 0010.\n   * Header Byte: 10 0010 01 = 0x89\n   * Following Data: 0x9C, 0x7F\n\n--------------------------------------------------------------------------------\n\n4.3.3. Sub-Type 10: Fixed Data Type#\n\n * Sub-Type Code (SS): 10\n * Purpose: Encodes a value belonging to a standard, fixed-size data type\n   identified by a type code.\n * Format:\n   * Header Byte: 10 TTTT 10\n     \n     BITS   FIELD              DESCRIPTION\n     7-6    Tag (10)           IxData Field family.\n     5-2    Type Code (TTTT)   Specifies the fixed data type (see table below).\n     1-0    Sub-Type (10)      Specifies Fixed Data Type format.\n   \n   * Data: Followed by the number of bytes corresponding to the specified Type\n     Code. Data is encoded in Little-Endian byte order where applicable\n     (multi-byte integers, floats).\n * Type Codes (TTTT):\n   \n   TTTT (BIN)   TTTT (DEC)   DATA TYPE   SIZE (BYTES)   NOTES\n   0000         0            int8_t      1              Signed 8-bit integer\n   0001         1            int16_t     2              Signed 16-bit integer\n   0010         2            int32_t     4              Signed 32-bit integer\n   0011         3            int64_t     8              Signed 64-bit integer\n   0100         4            uint8_t     1              Unsigned 8-bit integer\n   0101         5            uint16_t    2              Unsigned 16-bit integer\n   0110         6            uint32_t    4              Unsigned 32-bit integer\n   0111         7            uint64_t    8              Unsigned 64-bit integer\n   1000         8            float       4              IEEE 754 Single-Precision\n   1001         9            double      8              IEEE 754 Double-Precision\n   1010         10           Reserved    -              For future use\n   ...          ...          ...         ...            (Codes 10-15 are Reserved)\n   1111         15           Reserved    -              For future use\n\n * Constraints: The data following the header MUST match the size and format\n   required by the specified Type Code.\n * Total Size: 1 + Size(Type[TTTT]) bytes.\n * Reserved Values: Type codes 10 through 15 are reserved.\n * Example (Value -100 as int16_t):\n   * -100 is 0xFF9C (Little-Endian: 9C FF). TTTT = 0001.\n   * Header Byte: 10 0001 10 = 0x86\n   * Following Data: 0x9C, 0xFF\n\n--------------------------------------------------------------------------------\n\n4.3.4. Sub-Type 11: Single-Byte Constant/Marker#\n\n * Sub-Type Code (SS): 11\n * Purpose: Encodes specific predefined constant values (like boolean\n   true/false) or semantic markers using only a single byte. The meaning is\n   determined directly by the Value Code.\n * Format:\n   * Header Byte: 10 XXXX 11 (The header byte is the entire field)\n     \n     BITS   FIELD               DESCRIPTION\n     7-6    Tag (10)            IxData Field family.\n     5-2    Value Code (XXXX)   Specifies the constant or marker value (0-15).\n     1-0    Sub-Type (11)       Specifies Single-Byte Constant/Marker format.\n   \n   * Data: No following data bytes.\n * Value Codes (XXXX):\n   \n   XXXX (BIN)   XXXX (DEC)   HEADER BYTE (HEX)   DEFINED MEANING   NOTES\n   0000         0            0x83                false             Boolean false value\n   0001         1            0x87                true              Boolean true value\n   0010         2            0x8B                Reserved          For future use\n   ...          ...          ...                 ...               (Codes 2-15 are Reserved)\n   1111         15           0xBF                Reserved          e.g., For Null, Separator\n\n * Constraints: Implementations should recognize the defined constant values.\n * Total Size: 1 byte.\n * Reserved Values: Value codes 2 through 15 are reserved for future standard\n   constants or markers.\n * Example (Representing false): The single byte 10 0000 11 = 0x83 is used.\n\n--------------------------------------------------------------------------------\n\n\nRationale#\n\n * Sub-Typing: Utilizing the two previously reserved bits (1-0) of the Tag 10\n   header byte allows extending functionality significantly without consuming a\n   new top-level tag, preserving the core 2-bit tag structure of CTE.\n * Varint (SS=01): Adopting ULEB128 and SLEB128 provides standard, efficient\n   variable-length encodings for unsigned and signed integers, respectively.\n   Including a direct representation for '0' (EEEE=0000) optimizes the most\n   common default integer value.\n * Fixed Types (SS=10): Directly encoding common fixed-width types (integers up\n   to 64 bits, float, double) is often more convenient and potentially faster to\n   decode than using variable-length encodings or the generic Command Data field\n   for these types. Little-Endian is chosen as a common standard.\n * Single-Byte Constants (SS=11): Allocating a dedicated sub-type for\n   single-byte constants like true and false provides an unambiguous and highly\n   efficient (1 byte) representation. This keeps the SS=10 (Fixed Type) logic\n   consistent (header always implies following data) and leaves room in SS=11\n   for other markers (e.g., null, separators) if needed later.\n\n\nBackwards Compatibility#\n\nThis proposal introduces new interpretations for the Tag 10 field based on the\nvalue of bits 1-0.\n\n * Partially Compatible: CTE processors compliant only with v1.0 will correctly\n   interpret the Legacy Index Reference (SS=00) sub-type, as its format (10 IIII\n   00) remains unchanged.\n * Incompatible: V1.0 processors will not recognize or correctly decode data\n   encoded using the new sub-types (SS=01, SS=10, SS=11). Encountering these\n   formats will likely lead to parsing errors or data misinterpretation.\n\nAdoption of this LIP requires updating CTE processors to recognize and handle\nall four defined sub-types of the Tag 10 IxData Field. This change effectively\ndefines CTE v1.1.\n\n\nSecurity Considerations#\n\n * LEB128 Decoding (SS=01): Implementations decoding ULEB128 and SLEB128 must\n   protect against potential resource exhaustion attacks. Maliciously crafted\n   long sequences (many bytes with continuation bits set) could cause excessive\n   CPU usage or memory allocation during decoding. Robust decoders should\n   enforce limits on the number of bytes read for a single LEB128 value or check\n   the magnitude of the partially decoded value against reasonable bounds (e.g.,\n   max 128 bits, or application-specific limits) related to the overall\n   transaction size limit.\n * Fixed Type Decoding (SS=10): Decoders must ensure sufficient bytes are\n   available in the input buffer before attempting to read the data associated\n   with a fixed type to prevent buffer over-reads. The required size is known\n   directly from the TTTT code.\n\n\nCopyright#\n\nThis LIP is licensed under the MIT License, in alignment with the main LEA\nProject License.","routePath":"/lips/LIP-0001","lang":"","toc":[{"text":"Abstract","id":"abstract","depth":2,"charIndex":184},{"text":"Motivation","id":"motivation","depth":2,"charIndex":767},{"text":"Specification","id":"specification","depth":2,"charIndex":1789},{"text":"4.3. Index and Extended Data Field (IxData Field) (Tag `10`)","id":"43-index-and-extended-data-field-ixdata-field-tag-10","depth":3,"charIndex":-1},{"text":"4.3.1. Sub-Type `00`: Legacy Index Reference","id":"431-sub-type-00-legacy-index-reference","depth":4,"charIndex":-1},{"text":"4.3.2. Sub-Type `01`: Variable-Length Encoded Integer (Varint)","id":"432-sub-type-01-variable-length-encoded-integer-varint","depth":4,"charIndex":-1},{"text":"4.3.3. Sub-Type `10`: Fixed Data Type","id":"433-sub-type-10-fixed-data-type","depth":4,"charIndex":-1},{"text":"4.3.4. Sub-Type `11`: Single-Byte Constant/Marker","id":"434-sub-type-11-single-byte-constantmarker","depth":4,"charIndex":-1},{"text":"Rationale","id":"rationale","depth":2,"charIndex":10585},{"text":"Backwards Compatibility","id":"backwards-compatibility","depth":2,"charIndex":11767},{"text":"Security Considerations","id":"security-considerations","depth":2,"charIndex":12484},{"text":"Copyright","id":"copyright","depth":2,"charIndex":13346}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"","content":" * LIP: 2\n * Layer: Core Encoding\n * Title: Typed Crypto Schemes and Segregated PQC Signature Proofs\n * Author: Allwin Ketnawang\n * Created: 2025-04-28\n * Superseded-By: 6\n * Status: Replaced\n\n\nAbstract#\n\nThis LIP proposes extending the CTE specification to support multiple\ncryptographic schemes, including Post-Quantum Cryptography (PQC) algorithms like\nSLH-DSA (also known as SPHINCS+). It utilizes the two previously reserved\npadding bits within the header bytes of the Public Key List (Tag 00) and\nSignature List (Tag 01) fields to encode the specific cryptographic scheme being\nused. For PQC signatures, which are typically very large, this proposal adopts a\nsegregated proof model: only a 32-byte BLAKE3 hash of the PQC signature is\nstored on-chain within the Signature List field, while the full signature proof\nis expected to be distributed via a separate mechanism. This allows LEA\nblockchain transactions to gain PQC resistance while maintaining the core\ncompactness principle of CTE.\n\n\nMotivation#\n\nAs quantum computing advances, blockchains need to transition to PQC algorithms\nto ensure long-term security. However, many PQC signatures are significantly\nlarger than traditional signatures (e.g., Ed25519 used in CTE v1.0), potentially\nexceeding CTE's strict Maximum Transaction Size limit (1232 bytes). Storing\nthese large signatures directly on-chain would undermine CTE's efficiency and\ncompactness.\n\nThis proposal aims to:\n\n 1. Introduce a mechanism to identify different cryptographic schemes (standard\n    ECC and PQC) within the existing CTE structure without consuming new tags.\n 2. Enable the use of PQC public keys (specifically SLH-DSA variants) within\n    transactions.\n 3. Allow verification of PQC signatures without storing the entire large\n    signature on-chain, by committing only to a secure hash (BLAKE3) of the\n    signature within the transaction data.\n\nThis approach maintains small transaction sizes while paving the way for quantum\nresistance.\n\n\nSpecification#\n\nThis LIP modifies Sections 4.1 and 4.2 of the CTE v1.0 specification by\nassigning meaning to the previously reserved bits 1-0 of their respective header\nbytes.\n\n--------------------------------------------------------------------------------\n\n\n4.1. Public Key List (Tag 00) - Updated#\n\n * Tag: 00\n * Purpose: Encodes a list of one or more public keys used within the\n   transaction. The type and size of the keys are determined by the header\n   byte's Type Code bits.\n * Format:\n   * Header Byte:\n     \n     BITS   FIELD            DESCRIPTION\n     7-6    Tag (00)         Identifies this as a Public Key List.\n     5-2    Length (N)       Number of keys in the list (1-15).\n     1-0    Type Code (TT)   Specifies the cryptographic scheme (see table below).\n   \n   * Data: Followed by N contiguous public keys. The size of each key depends on\n     the Type Code.\n * Type Codes (TT):\n   \n   TT (BIN)   TT (DEC)   CRYPTOGRAPHIC SCHEME   KEY SIZE (BYTES)   NOTES\n   00         0          Ed25519                32                 CTE v1.0 Default\n   01         1          SLH-DSA-SHA2-128f      32                 SPHINCS+ variant public key\n   10         2          SLH-DSA-SHA2-192f      48                 SPHINCS+ variant public key\n   11         3          SLH-DSA-SHA2-256f      64                 SPHINCS+ variant public key\n\n * Constraints:\n   * The Length field (N) must be between 1 and 15.\n   * The total size = 1 + (N * Size(Type[TT])) bytes. Implementations must\n     consider the overall transaction size limit.\n\n--------------------------------------------------------------------------------\n\n\n4.2. Signature List (Tag 01) - Updated#\n\n * Tag: 01\n * Purpose: Encodes a list of one or more cryptographic signatures or signature\n   hashes used to authorize the transaction. The format (full signature or hash)\n   and the underlying scheme are determined by the header byte's Type Code bits.\n * Format:\n   * Header Byte:\n     \n     BITS   FIELD            DESCRIPTION\n     7-6    Tag (01)         Identifies this as a Signature List.\n     5-2    Length (N)       Number of signatures/hashes in list (1-15).\n     1-0    Type Code (TT)   Specifies the scheme and format (see table below).\n   \n   * Data: Followed by N contiguous signatures or signature hashes. The size of\n     each item depends on the Type Code.\n * Type Codes (TT):\n   \n   TT (BIN)   TT (DEC)   CRYPTOGRAPHIC SCHEME / FORMAT                ITEM SIZE (BYTES)   NOTES\n   00         0          Ed25519 Signature                            64                  CTE v1.0 Default, full signature\n   01         1          BLAKE3 Hash of SLH-DSA-SHA2-128f Signature   32                  256-bit hash of the corresponding full PQC signature proof\n   10         2          BLAKE3 Hash of SLH-DSA-SHA2-192f Signature   32                  256-bit hash of the corresponding full PQC signature proof\n   11         3          BLAKE3 Hash of SLH-DSA-SHA2-256f Signature   32                  256-bit hash of the corresponding full PQC signature proof\n\n * Constraints:\n   * The Length field (N) must be between 1 and 15.\n   * For TT = 01, 10, 11, the data represents a 32-byte hash generated using the\n     BLAKE3 cryptographic hash function on the full PQC signature.\n   * The validation process for TT = 01, 10, 11 requires obtaining the\n     corresponding full PQC signature proof from an external source (off-chain\n     mechanism), verifying the proof against the public key, and then hashing\n     the proof with BLAKE3 to compare against the 32-byte hash stored in this\n     field.\n   * Total size = 1 + (N * Size(Type[TT])) bytes.\n\n--------------------------------------------------------------------------------\n\n\nOff-Chain Proof Distribution#\n\nThe mechanism for distributing and retrieving the full PQC signature proofs\ncorresponding to the on-chain hashes (TT = 01, 10, 11 in Tag 01) is outside the\nscope of this core encoding specification but is a critical component required\nfor validation. Implementations MUST ensure a reliable and secure system for\nthis purpose.\n\n--------------------------------------------------------------------------------\n\n\nRationale#\n\n * Leveraging Reserved Bits: Using the 2 reserved bits in the Tag 00 and 01\n   headers is the intended mechanism for extending CTE functionality without\n   consuming new tags, maintaining the compact 2-bit tag structure. This\n   provides 4 type codes, sufficient for the default scheme and the initial set\n   of PQC algorithms.\n * Segregated Proofs: Storing only a hash of large PQC signatures on-chain\n   drastically reduces the data footprint, preserving CTE's suitability for\n   constrained environments. This avoids a potentially massive increase in the\n   Maximum Transaction Size.\n * BLAKE3 Hash: BLAKE3 is chosen as a modern, high-performance, and secure\n   cryptographic hash function suitable for generating the 32-byte (256-bit)\n   on-chain commitments.\n * PQC Algorithm Choice: SLH-DSA (SPHINCS+) is selected as a prominent stateless\n   hash-based signature scheme, known for its strong security properties against\n   quantum adversaries. The specific variants (128f, 192f, 256f) offer different\n   security/performance trade-offs.\n\n\nBackwards Compatibility#\n\n * Transactions using only Type Code 00 in the Public Key List and Signature\n   List headers remain compatible with CTE v1.0 / v1.1 parsers that ignore or\n   expect the padding bits to be zero.\n * Transactions utilizing the new Type Codes (01, 10, 11) in either header are\n   incompatible with older parsers. These parsers will likely fail or\n   misinterpret the data due to unexpected key/signature sizes or formats.\n * Adoption of this LIP requires updating CTE processors to recognize and handle\n   all defined Type Codes for Tags 00 and 01. This change effectively defines\n   CTE v1.2 (or potentially CTE v2.0 depending on community consensus regarding\n   the significance of PQC integration and the segregated proof model).\n\n\nSecurity Considerations#\n\n * Off-Chain Proof Availability & Integrity: The security of the entire system\n   heavily relies on the external mechanism used to distribute and retrieve the\n   full PQC signature proofs. This mechanism must guarantee proof availability\n   for validation and resist tampering or censorship. Delays or failures in\n   retrieving proofs can stall transaction validation. The design of this\n   mechanism is critical.\n * Validation Logic: Validators must implement robust logic to fetch the correct\n   off-chain proof, verify it using the appropriate PQC algorithm (indicated by\n   the Type Code) against the public key (also typed), and then hash the\n   verified proof with BLAKE3 to compare against the on-chain hash. Any failure\n   in this chain invalidates the transaction authorization.\n * PQC Public Key Sizes: While this LIP allows specifying different PQC public\n   key types, including the full keys in the Public Key List still consumes\n   transaction space (32, 48, or 64 bytes per key). Applications should consider\n   the impact on the overall transaction size limit.\n\n\nCopyright#\n\nThis LIP is licensed under the MIT License, in alignment with the main LEA\nProject License.","routePath":"/lips/LIP-0002","lang":"","toc":[{"text":"Abstract","id":"abstract","depth":2,"charIndex":193},{"text":"Motivation","id":"motivation","depth":2,"charIndex":997},{"text":"Specification","id":"specification","depth":2,"charIndex":1983},{"text":"4.1. Public Key List (Tag `00`) - Updated","id":"41-public-key-list-tag-00---updated","depth":3,"charIndex":-1},{"text":"4.2. Signature List (Tag `01`) - Updated","id":"42-signature-list-tag-01---updated","depth":3,"charIndex":-1},{"text":"Off-Chain Proof Distribution","id":"off-chain-proof-distribution","depth":3,"charIndex":5679},{"text":"Rationale","id":"rationale","depth":2,"charIndex":6120},{"text":"Backwards Compatibility","id":"backwards-compatibility","depth":2,"charIndex":7177},{"text":"Security Considerations","id":"security-considerations","depth":2,"charIndex":7934},{"text":"Copyright","id":"copyright","depth":2,"charIndex":9039}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"","content":" * LIP: 3\n * Layer: Meta/Process\n * Title: LIP Structure and Process\n * Author: Allwin Ketnawang\n * Created: 2025-04-28\n * Status: Proposed\n\n\nAbstract#\n\nThis LIP defines the standard structure, required sections, header fields, and\nlifecycle statuses for LEA Improvement Proposals (LIPs). Establishing a\nconsistent format and process facilitates clear communication, effective review,\nand organized tracking of proposed changes to the LEA protocol and ecosystem.\nThis document itself follows the proposed standard.\n\n\nMotivation#\n\nAs the LEA project evolves, a standardized process for proposing, discussing,\nand tracking changes becomes essential. Currently, there is no formal definition\nfor how improvement proposals should be structured or managed. This leads to\npotential inconsistencies, makes proposals harder to compare and review, and\ncomplicates tracking their progress. LIP-3 aims to rectify this by establishing\na clear template and defined lifecycle for all future LIPs, improving clarity\nand efficiency in the development process.\n\n\nSpecification#\n\nAll LEA Improvement Proposals MUST adhere to the following Markdown structure\nand include the defined header fields and sections.\n\n\n1. LIP Header Preamble#\n\nEach LIP must begin with a header section containing the following fields:\n\n * LIP: (Required) The LIP number, assigned sequentially (e.g., 3).\n * Layer: (Required) The area of the LEA protocol or ecosystem affected. See\n   Layer Definitions below.\n * Title: (Required) A concise title summarizing the proposal's content.\n * Author: (Required) A list of the author(s) or primary champion(s) of the\n   proposal, using names or handles.\n * Discussions-To: (Optional) A URL pointing to the primary discussion forum,\n   issue tracker thread, or mailing list archive for this LIP.\n * Created: (Required) The date the LIP was first formally drafted (YYYY-MM-DD).\n * Updated: (Optional) The date the LIP was last significantly updated\n   (YYYY-MM-DD).\n * Requires: (Optional) A list of LIP number(s) that this LIP depends on.\n * Replaces: (Optional) A list of LIP number(s) that this LIP renders obsolete.\n * Superseded-By: (Optional) A list of LIP number(s) that render this LIP\n   obsolete.\n * Status: (Required) The current stage of the LIP in its lifecycle. See Status\n   Definitions below.\n\n\n2. LIP Body Sections#\n\nFollowing the header, each LIP must include these sections:\n\n * Abstract: A brief (~200 word) summary of the proposal.\n * Motivation: Explanation of the problem being solved and the rationale for the\n   proposal.\n * Specification: Detailed technical description of the proposed changes.\n * Rationale: Justification for design choices and discussion of alternatives\n   considered.\n * Backwards Compatibility: Analysis of compatibility with existing systems and\n   transition plans if applicable.\n * Security Considerations: Assessment of potential security impacts.\n * Copyright: Statement of the license under which the LIP is released\n   (typically CC0 waiver or MIT License).\n\n\n3. Layer Definitions#\n\nThe Layer field categorizes the LIP. Defined layers are:\n\n * Core Encoding: Changes to data serialization (e.g., CTE).\n * Consensus: Changes to network agreement rules.\n * Networking: Changes to peer-to-peer protocols.\n * API/RPC: Changes to node interaction interfaces.\n * Application: Standards for applications built on LEA.\n * Meta/Process: Changes to the LIP process itself (like this LIP).\n\n\n4. Status Definitions#\n\nThe Status field tracks the LIP's lifecycle stage:\n\n * Idea: Informal concept stage.\n * Draft: Initial formal written version for discussion.\n * Proposed: Mature draft ready for formal review.\n * Approved / Accepted: Formally accepted for implementation.\n * Active / Final: Implemented and part of the official specification/protocol.\n * Deferred: Postponed for later consideration.\n * Rejected: Formally declined.\n * Withdrawn: Retracted by the author(s).\n * Replaced / Superseded: Made obsolete by a newer LIP.\n\n\n5. LIP Template Markdown#\n\nThe following Markdown code block represents the standard template to be used\nfor new LIPs:\n\n\n\n\nRationale#\n\nAdopting a standardized structure based on common practices in other blockchain\nprojects (like BIPs/EIPs) provides immediate clarity and familiarity. The chosen\nsections cover the essential aspects needed to understand, evaluate, and\nimplement a proposal. Defining layers helps categorize proposals, while defined\nstatuses provide a clear view of the proposal lifecycle. Making this definition\nitself a LIP ensures the process is self-documenting and can be updated via the\nsame mechanism if needed.\n\n\nBackwards Compatibility#\n\nThis LIP defines a process and does not directly impact the LEA protocol's\ntechnical backwards compatibility. It applies to LIPs created after its\nacceptance.\n\n\nSecurity Considerations#\n\nStandardizing the proposal process does not introduce direct technical\nvulnerabilities. However, adherence to the process, particularly the Security\nConsiderations section within each LIP, is crucial for maintaining the overall\nsecurity of the LEA protocol as it evolves. Ensuring clear documentation and\nreview helps prevent unintentional security issues.\n\n\nCopyright#\n\nThis LIP is licensed under the MIT License, in alignment with the main LEA\nProject License.","routePath":"/lips/LIP-0003","lang":"","toc":[{"text":"Abstract","id":"abstract","depth":2,"charIndex":141},{"text":"Motivation","id":"motivation","depth":2,"charIndex":516},{"text":"Specification","id":"specification","depth":2,"charIndex":1045},{"text":"1. LIP Header Preamble","id":"1-lip-header-preamble","depth":3,"charIndex":1193},{"text":"2. LIP Body Sections","id":"2-lip-body-sections","depth":3,"charIndex":2308},{"text":"3. Layer Definitions","id":"3-layer-definitions","depth":3,"charIndex":3011},{"text":"4. Status Definitions","id":"4-status-definitions","depth":3,"charIndex":3432},{"text":"5. LIP Template Markdown","id":"5-lip-template-markdown","depth":3,"charIndex":3971},{"text":"Rationale","id":"rationale","depth":2,"charIndex":4094},{"text":"Backwards Compatibility","id":"backwards-compatibility","depth":2,"charIndex":4608},{"text":"Security Considerations","id":"security-considerations","depth":2,"charIndex":4795},{"text":"Copyright","id":"copyright","depth":2,"charIndex":5180}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"","content":" * LIP: 4\n * Layer: Core Encoding\n * Title: Decouple Legacy Index Field from List Context\n * Author: Allwin Ketnawang\n * Created: 2025-05-01\n * Superseded-By: 6\n * Status: Replaced\n\n\nAbstract#\n\nThis LIP proposes modifying the definition and processing rules for the IxData\nField Sub-Type 00 (\"Legacy Index Reference\"), as introduced in LIP-1. While\nretaining its semantic meaning as an index into a Public Key List or Signature\nList present within the transaction, this proposal removes the requirement that\nthe index field must immediately follow the list it references. The\nresponsibility for associating the index with the correct list and performing\nthe bounds check is shifted from the raw decoder to the higher-level application\nlogic consuming the decoded stream.\n\n\nMotivation#\n\nThe current specification (CTE v1.1 / LIP-1) requires the IxData Sub-Type 00\nfield (10 IIII 00) to immediately follow the Public Key or Signature List it\nreferences. This restricts its use, particularly within Command Data (Tag 11).\nThis proposal allows the 10xxxx00 field to appear anywhere, including within the\nencoded payload of a command (e.g., smart contract arguments). This enables\ncommands or contracts to compactly reference items (like public keys or\nsignatures) from lists defined earlier in the transaction, leaving the\ninterpretation (which list is referenced) and bounds checking to the application\nor contract logic.\n\n\nSpecification#\n\nThis LIP modifies the description and constraints associated with Section 4.3.1\n(\"Sub-Type 00: Legacy Index Reference\") of the CTE specification, as previously\ndefined by LIP-1. The field format remains unchanged.\n\nThe modified Section 4.3.1 reads as follows:\n\n--------------------------------------------------------------------------------\n\n4.3.1. Sub-Type 00: List Index Reference#\n\n * Sub-Type Code (SS): 00\n * Purpose: Provides a zero-based index referencing an item within a Public Key\n   List (Section 4.1) or Signature List (Section 4.2) that exists elsewhere\n   within the same CTE transaction.\n * Format:\n   * Header Byte: 10 IIII 00\n     \n     BITS   FIELD           DESCRIPTION\n     7-6    Tag (10)        IxData Field family.\n     5-2    Index (IIII)    The 4-bit index value (0-15).\n     1-0    Sub-Type (00)   Specifies List Index Reference format.\n   \n   * Data: No following data bytes.\n * Constraints:\n   * The Index value (IIII) MUST correspond to a valid position within the\n     intended target list (Public Key or Signature List).\n   * The association between this index field and its target list (i.e., whether\n     it refers to the Public Key List or the Signature List) is not defined at\n     the raw CTE encoding layer but MUST be defined by the application or\n     higher-level protocol interpreting the CTE stream.\n   * The validation that the Index value is within the bounds of the target list\n     (Index < list_size) MUST be performed by the application logic, using the\n     decoded index and the size of the appropriate target list (obtained when\n     decoding that list).\n * Total Size: 1 byte.\n * Reserved Values: None within this sub-type.\n * Example (Encoding index 1): Header Byte: 10 0001 00 = 0x84. (The application\n   logic determines if this refers to the PubKey list or Sig list and performs\n   bounds checks accordingly).\n\n--------------------------------------------------------------------------------\n\nSummary of Changes:\n\n 1. The section title is changed back to \"List Index Reference\" (or similar) to\n    reflect its purpose.\n 2. The description clarifies that the referenced list can be elsewhere in the\n    transaction, not necessarily immediately preceding.\n 3. Explicit constraints are added stating that:\n    * The target list association is application-defined.\n    * The bounds checking responsibility lies with the application, not the raw\n      decoder.\n 4. The previous decoder constraint requiring last_list_count > 0 is removed\n    from the raw decoding step for this field.\n\n\nRationale#\n\nThis approach balances flexibility with semantic clarity:\n\n * Flexibility: Allows indices to be placed anywhere, including within Command\n   Data payloads, enabling more complex or optimized transaction structures and\n   smart contract interactions.\n * Preserved Meaning: The field (10xxxx00) retains its specific meaning as a\n   list index, preventing it from being overloaded as a generic 4-bit integer,\n   which could lead to ambiguity.\n * Clear Responsibility: Explicitly defines that the context (which list is\n   targeted) and bounds validation are application-level concerns. The raw CTE\n   decoder's job is simply to extract the 4-bit index value from this field\n   type.\n * Minimal Encoding Change: Achieves the goal without altering the byte-level\n   format of the field itself.\n\n\nSecurity Considerations#\n\n * Application-Level Validation Crucial: The primary security consideration is\n   ensuring that the application logic correctly associates each index with its\n   intended target list and performs rigorous bounds checking. Failure to do so\n   could lead to vulnerabilities, such as using the wrong public key for\n   verification or referencing non-existent signatures.\n\n\nCopyright#\n\nThis LIP is licensed under the MIT License, in alignment with the main LEA\nProject License.","routePath":"/lips/LIP-0004","lang":"","toc":[{"text":"Abstract","id":"abstract","depth":2,"charIndex":182},{"text":"Motivation","id":"motivation","depth":2,"charIndex":772},{"text":"Specification","id":"specification","depth":2,"charIndex":1420},{"text":"4.3.1. Sub-Type `00`: List Index Reference","id":"431-sub-type-00-list-index-reference","depth":4,"charIndex":-1},{"text":"Rationale","id":"rationale","depth":2,"charIndex":3975},{"text":"Security Considerations","id":"security-considerations","depth":2,"charIndex":4778},{"text":"Copyright","id":"copyright","depth":2,"charIndex":5174}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"","content":" * LIP: 5\n * Layer: Core Encoding\n * Title: Generalize Vectors with Explicit Entry Sizes\n * Author: Allwin Ketnawang\n * Created: 2025-07-03\n * Replaces: 2\n * Superseded-By: 6\n * Status: Replaced\n\n\nAbstract#\n\nThis LIP proposes a fundamental, breaking change to the CTE specification. It\nrenames Public Key List and Signature List to Public Key Vector and Signature\nVector, and renames Legacy Index Reference to Vector Index.\n\nCrucially, it replaces the concept of a crypto-specific type code (as defined in\nLIP-2) with a generic entry size code. The TT bits in the vector headers will\nnow explicitly define the byte size of each element in the vector's data\npayload. This simplifies the core CTE parsing logic by decoupling it from\ncryptographic scheme specifics, making the format more flexible and\nforward-compatible. This proposal renders LIP-2 obsolete.\n\n\nMotivation#\n\nLIP-2 coupled the TT type code directly to a cryptographic algorithm (e.g.,\nTT=00 for Ed25519). While this provided semantic meaning at the parsing layer,\nit also made the core format rigid. Adding a new algorithm or a variant with the\nsame key size would require a new TT code and a specification update.\n\nThis proposal simplifies the parser's responsibility to a purely structural one:\nread a vector of N items, where each item is X bytes long. The TT code now\nsimply defines 'X'. The semantic interpretation of what those bytes represent\n(e.g., an Ed25519 key vs. an SLH-DSA key) is moved to the application layer,\nwhere it ultimately matters. This makes the base CTE format more generic and\nextensible. The renaming to \"Vector\" and \"Vector Index\" reflects this more\ngeneric, structural nature.\n\n\nSpecification#\n\nThis LIP replaces the specifications for Tag 00 and Tag 01 as defined in LIP-2\nand renames the IxData Sub-Type 00.\n\n--------------------------------------------------------------------------------\n\n\n4.1. Public Key Vector (Tag 00) - Updated#\n\n * Tag: 00\n * Purpose: Encodes a vector of one or more public keys. The size of each key is\n   determined by the header byte's Entry Size Code.\n * Header Byte:\n   \n   BITS   FIELD                  DESCRIPTION\n   7-6    Tag (00)               Identifies this as a Public Key Vector.\n   5-2    Length (N)             Number of keys in the vector (1-15).\n   1-0    Entry Size Code (TT)   Specifies the size of each key (see table below).\n\n * Entry Size Codes (TT):\n   \n   TT (BIN)   KEY SIZE (BYTES)\n   00         32\n   01         64\n   10         128\n   11         Unused\n\n--------------------------------------------------------------------------------\n\n\n4.2. Signature Vector (Tag 01) - Updated#\n\n * Tag: 01\n * Purpose: Encodes a vector of one or more cryptographic signatures or\n   signature hashes. The size of each item is determined by the header byte's\n   Entry Size Code.\n * Header Byte:\n   \n   BITS   FIELD                  DESCRIPTION\n   7-6    Tag (01)               Identifies this as a Signature Vector.\n   5-2    Length (N)             Number of items in the vector (1-15).\n   1-0    Entry Size Code (TT)   Specifies the size of each item (see table below).\n\n * Entry Size Codes (TT):\n   \n   TT (BIN)   ITEM SIZE (BYTES)\n   00         32\n   01         64\n   10         128\n   11         29792\n\n--------------------------------------------------------------------------------\n\n\n4.3.1. Vector Index (IxData Sub-Type 00) - Updated#\n\n * Name: The field previously known as Legacy Index Reference is renamed to\n   Vector Index.\n * Purpose: Provides a zero-based index into a Public Key Vector or Signature\n   Vector. The responsibility for determining which vector is being referenced\n   lies with the application layer, as per LIP-4.\n\n--------------------------------------------------------------------------------\n\n\nRationale#\n\n * Decoupling: This change decouples the core CTE parser from the complexities\n   of cryptographic validation. The parser's job is to validate structure, not\n   semantics.\n * Flexibility: The application layer can now define the meaning of a given\n   entry size (e.g., a 32-byte public key is Ed25519 for one transaction type,\n   and PQC for another). This requires no changes to the base protocol.\n * Forward Compatibility: New cryptographic schemes can be adopted without\n   requiring new TT codes, as long as their key or signature sizes fit one of\n   the existing size slots.\n\n\nBackwards Compatibility#\n\nThis proposal is a breaking change and is not backwards compatible with\nimplementations based on LIP-2.\n\n * Parsers compliant with LIP-2 expect the TT code to define a specific\n   cryptographic scheme. They will misinterpret the data if they receive a\n   stream based on this new specification.\n * For example, under LIP-2, a Signature field with TT=00 implies a 64-byte\n   Ed25519 signature. Under this proposal, TT=00 for a Signature Vector implies\n   a 32-byte item.\n * Adoption of this LIP requires a coordinated update of all CTE processors and\n   defines a new, incompatible version of the CTE protocol.\n\n\nSecurity Considerations#\n\nThe primary security consideration is that the responsibility for correctly\ninterpreting the cryptographic context of the data is now entirely on the\napplication layer.\n\n * Application logic MUST unambiguously determine the cryptographic algorithm to\n   be used based on the transaction type or other contextual information.\n * Failure to do so could lead to severe vulnerabilities, such as attempting to\n   validate a signature with the wrong algorithm or against a key of a different\n   type. The system's security now relies on the application layer being\n   correct.\n\n\nCopyright#\n\nThis LIP is licensed under the MIT License, in alignment with the main LEA\nProject License.","routePath":"/lips/LIP-0005","lang":"","toc":[{"text":"Abstract","id":"abstract","depth":2,"charIndex":196},{"text":"Motivation","id":"motivation","depth":2,"charIndex":858},{"text":"Specification","id":"specification","depth":2,"charIndex":1671},{"text":"4.1. Public Key Vector (Tag `00`) - Updated","id":"41-public-key-vector-tag-00---updated","depth":3,"charIndex":-1},{"text":"4.2. Signature Vector (Tag `01`) - Updated","id":"42-signature-vector-tag-01---updated","depth":3,"charIndex":-1},{"text":"4.3.1. Vector Index (IxData Sub-Type `00`) - Updated","id":"431-vector-index-ixdata-sub-type-00---updated","depth":3,"charIndex":-1},{"text":"Rationale","id":"rationale","depth":2,"charIndex":3756},{"text":"Backwards Compatibility","id":"backwards-compatibility","depth":2,"charIndex":4350},{"text":"Security Considerations","id":"security-considerations","depth":2,"charIndex":4988},{"text":"Copyright","id":"copyright","depth":2,"charIndex":5587}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"","content":" * LIP: 6\n * Layer: Core Encoding\n * Title: Replace Core Transaction Encoding (CTE) with Simple Compact\n   Transaction Protocol (SCTP)\n * Author: Allwin Ketnawang\n * Created: 2025-07-07\n * Replaces: 1, 2, 4, 5\n * Status: Proposed\n\n\nAbstract#\n\nThis LIP officially deprecates the Core Transaction Encoding (CTE) and all\nassociated improvement proposals (LIPs 1, 2, 4, 5). It is replaced by a new,\nstreamlined encoding standard known as the \"Simple Compact Transaction Protocol\"\n(SCTP). This proposal formalizes the transition and contains the complete\ntechnical specification for SCTP, marking a fundamental shift in the project's\napproach to data serialization.\n\n\nMotivation#\n\nThe Core Transaction Encoding (CTE) was becoming increasingly complex. A series\nof proposed extensions (LIPs 1, 2, 4, 5) highlighted that incremental patches\nwere leading to a fragmented and overly complicated design. Rather than\ncontinuing to amend the original specification, a decision was made to develop a\nnew encoding from the ground up. The Simple Compact Transaction Protocol (SCTP)\nwas designed to be simpler, more performant, and more extensible than CTE. This\nLIP serves to formally ratify the switch, providing a clean break from the\nlegacy system and establishing a more robust foundation for future development.\n\n\nSpecification#\n\nThe Core Transaction Encoding (CTE) is deprecated. All LEA-compliant systems\nwill adopt the Simple Compact Transaction Protocol (SCTP) for all transaction\nencoding purposes.\n\nThe following is the complete technical specification for SCTP.\n\n\nOverview#\n\nA SCTP stream is a sequence of typed data fields. Each field is prefixed with a\n1-byte header that defines its type and provides metadata. All multi-byte\ninteger and floating-point values are encoded in little-endian byte order.\n\nHeader Byte#\n\nEvery data field begins with a header byte, structured as follows:\n\nMMMM TTTT\n\n * TTTT (lower 4 bits): The Type Identifier. This specifies the data type of the\n   field.\n * MMMM (upper 4 bits): Metadata. Its meaning depends on the TTTT value.\n\n--------------------------------------------------------------------------------\n\n\nType Identifiers#\n\nThe TTTT bits map to the following data types.\n\nTYPE ID   NAME      DESCRIPTION\n0         INT8      Signed 8-bit integer.\n1         UINT8     Unsigned 8-bit integer.\n2         INT16     Signed 16-bit integer.\n3         UINT16    Unsigned 16-bit integer.\n4         INT32     Signed 32-bit integer.\n5         UINT32    Unsigned 32-bit integer.\n6         INT64     Signed 64-bit integer.\n7         UINT64    Unsigned 64-bit integer.\n8         ULEB128   Unsigned LEB128-encoded integer.\n9         SLEB128   Signed LEB128-encoded integer.\n10        FLOAT32   32-bit floating-point number.\n11        FLOAT64   64-bit floating-point number.\n12        SHORT     A small integer (0-15) in a single byte.\n13        VECTOR    A generic byte array.\n14                  (Reserved for future use)\n15        EOF       End of Stream marker.\n\n--------------------------------------------------------------------------------\n\n\nType Encoding Details#\n\nFixed-Size & Variable-Size Numerics#\n\n * Types: INT8 - UINT64, ULEB128, SLEB128, FLOAT32, FLOAT64\n * Encoding: The header's MMMM bits are unused and should be 0000. The binary\n   data of the specified type immediately follows the header byte.\n\nSHORT#\n\n * Description: Encodes a small, unsigned integer value from 0 to 15.\n * Encoding: The entire field is a single byte.\n   * The TTTT bits identify the type as SHORT.\n   * The MMMM bits contain the actual integer value.\n\nVECTOR#\n\n * Description: Encodes a variable-length array of bytes.\n\n * Encoding: The MMMM bits in the header determine how the size is encoded.\n   \n   * Case 1: Small Vector (0-14 bytes)\n     \n     * The MMMM bits hold the length of the vector (0000 to 1110).\n     * The vector's byte data immediately follows the header.\n   \n   * Case 2: Large Vector (>= 15 bytes)\n     \n     * The MMMM bits are set to 1111.\n     * This signals that a ULEB128-encoded integer representing the vector's\n       true length follows the header.\n     * The vector's byte data follows the ULEB128 length.\n\nEOF#\n\n * Description: Marks the end of the data stream.\n * Encoding: A single byte where the TTTT bits are 1111. The MMMM bits should be\n   0000.\n\n--------------------------------------------------------------------------------\n\n\nRationale#\n\nA new, unified encoding standard is preferable to a heavily patched legacy\nsystem. By replacing CTE with SCTP, we avoid the accumulated complexity of\nmultiple LIPs and introduce a more coherent design. Embedding the specification\ndirectly into the LIP ensures that the proposal and its technical details are\nreviewed and approved as a single, atomic unit.\n\n\nBackwards Compatibility#\n\nThis is a fundamental breaking change. Transactions encoded using the legacy CTE\nformat are not compatible with the new SCTP standard and will be invalid. This\nchange necessitates a coordinated network upgrade. A specific block height or\n\"flag day\" will be designated for the switchover from CTE to SCTP. All node\noperators and developers must upgrade their software to a version that supports\nSCTP before this activation point to remain on the network.\n\n\nSecurity Considerations#\n\nThe security of the LEA protocol now depends entirely on the correctness and\nrobustness of the SCTP specification and its implementations. Implementers must\nbe diligent in creating parsers that are robust against malformed or malicious\ndata to prevent potential vulnerabilities, especially when decoding\nvariable-length structures like VECTOR, ULEB128, and SLEB128. The deprecation of\nCTE removes any security concerns associated with its previous complexity and\npatches.\n\n\nCopyright#\n\nThis LIP is licensed under the MIT License, in alignment with the main LEA\nProject License.","routePath":"/lips/LIP-0006","lang":"","toc":[{"text":"Abstract","id":"abstract","depth":2,"charIndex":231},{"text":"Motivation","id":"motivation","depth":2,"charIndex":662},{"text":"Specification","id":"specification","depth":2,"charIndex":1303},{"text":"Overview","id":"overview","depth":3,"charIndex":1560},{"text":"Header Byte","id":"header-byte","depth":4,"charIndex":1801},{"text":"Type Identifiers","id":"type-identifiers","depth":3,"charIndex":2142},{"text":"Type Encoding Details","id":"type-encoding-details","depth":3,"charIndex":3070},{"text":"Fixed-Size & Variable-Size Numerics","id":"fixed-size--variable-size-numerics","depth":4,"charIndex":3094},{"text":"`SHORT`","id":"short","depth":4,"charIndex":-1},{"text":"`VECTOR`","id":"vector","depth":4,"charIndex":-1},{"text":"`EOF`","id":"eof","depth":4,"charIndex":-1},{"text":"Rationale","id":"rationale","depth":2,"charIndex":4380},{"text":"Backwards Compatibility","id":"backwards-compatibility","depth":2,"charIndex":4750},{"text":"Security Considerations","id":"security-considerations","depth":2,"charIndex":5232},{"text":"Copyright","id":"copyright","depth":2,"charIndex":5732}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"","content":" * LIP: 7\n * Layer: Application\n * Title: Genesis LEA Transaction Decoder Format\n * Author: Allwin Ketnawang\n * Created: 2025-07-07\n * Requires: 6\n * Status: Draft\n\n\nAbstract#\n\nThis LIP defines the official, standardized binary layout interpreted by the\nGenesis LEA Transaction Decoder.\n\nAs the first canonical decoder in the LEA model, it is based on the Simple\nCompact Transaction Protocol (SCTP) primitives introduced in LIP-6. The format\nfollows a flexible, invocation-based structure, including a unified address\nvector, gas configuration, a sequence of invocation instructions, and a\ndual-signature scheme (Ed25519 and SPHINCS-256s).\n\n\nMotivation#\n\nWhile LIP-6 defines the low-level data primitives for encoding data, it does not\ndefine the high-level structure of a transaction (the \"grammar\"). A standard\ntransaction format is essential for all network participants to interpret,\nvalidate, and process transactions in a uniform way. This proposal provides that\nstandard, detailing the exact order, type, and meaning of each component within\na transaction. It also specifies the precise method for hashing and signing\ntransactions to ensure cryptographic integrity.\n\n\nSpecification#\n\nAll LEA transactions MUST be serialized according to the following structure,\nusing the SCTP encoding types defined in LIP-6. The transaction's total decoded\nsize MUST NOT exceed 1MB.\n\n\nCore Type System#\n\nThe transaction format utilizes a specific subset of the SCTP types:\n\nSCTP TYPE ID   NAME      DESCRIPTION\n8              ULEB128   Unsigned variable-length integer\n13             VECTOR    Raw byte array with a length prefix\n15             EOF       End-of-transaction marker (literal byte: 0x0F)\n\n--------------------------------------------------------------------------------\n\n\nLEA Transaction Format (as interpreted by Genesis Decoder)#\n\nA transaction is a sequence of core fields followed by a variable number of\nInvocation blocks and SignaturePair blocks.\n\nFIELD         TYPE              DESCRIPTION\nversion       ULEB128           Transaction format version\nsequence      ULEB128           Sender's nonce or sequence number\naddresses     VECTOR            32-byte addresses; signers first, fee payer first\ngasLimit      ULEB128           Max gas units allowed\ngasPrice      ULEB128           Price per gas unit\ninvocations   Invocation[]      One or more invocation instructions\nsignatures    SignaturePair[]   One signature pair per signer\nEOF           Byte (0x0F)       End-of-transaction marker (literal byte)\n\n--------------------------------------------------------------------------------\n\n\nInvocation Block#\n\nFIELD          TYPE      DESCRIPTION\ntargetIndex    ULEB128   Index into the addresses vector (0-based)\ninstructions   VECTOR    Instruction bytecode intended for the target address\n\n--------------------------------------------------------------------------------\n\n\nSignaturePair Block#\n\nFIELD                  TYPE                   DESCRIPTION\ned25519Signature       VECTOR (64 bytes)      Ed25519 signature over the hash\nsphincs256sSignature   VECTOR (29792 bytes)   SPHINCS-256s signature for PQC security\n\n--------------------------------------------------------------------------------\n\n\nNotation Key#\n\n * [] = Repeating block (zero or more)\n * VECTOR = Length-prefixed byte array\n * All field names are case-sensitive and must follow the specified order\n\n--------------------------------------------------------------------------------\n\n\nField Constraints and Rules#\n\n 1. Addresses (addresses):\n    \n    * This field is a single SCTP VECTOR containing all 32-byte addresses\n      involved in the transaction.\n    * The total byte length of the vector MUST be a multiple of 32.\n    * Addresses requiring a signature MUST be placed at the beginning of the\n      vector.\n    * The first address in the addresses vector is designated as the fee payer.\n    * Addresses that do not provide a signature can be included at the end of\n      the vector to serve as a lookup table for invocations.\n\n 2. Invocations:\n    \n    * The transaction contains one or more Invocation blocks.\n    * Each Invocation consists of a targetIndex (ULEB128) followed by an\n      instructions field (VECTOR).\n    * The targetIndex MUST be a valid, 0-based index into the addresses vector.\n    * The instructions field contains the application-specific instruction\n      bytecode to be executed in the context of the targeted address.\n\n 3. Signature Set:\n    \n    * The number of SignaturePair blocks implicitly defines the number of signed\n      addresses. If there are N signature pairs, then the first N addresses in\n      the addresses vector are considered signers.\n    * Each SignaturePair corresponds one-to-one with the signers in the\n      addresses vector by index.\n    * Each SignaturePair contains two VECTORs:\n      * ed25519Signature: A 64-byte Ed25519 signature.\n      * sphincs256sSignature: A 29,792-byte SPHINCS-256s signature.\n\n 4. Termination:\n    \n    * Every valid transaction MUST end with a single EOF byte (0x0F).\n    * No other data is permitted after the EOF marker.\n\n--------------------------------------------------------------------------------\n\n\nHashing and Signing Protocol#\n\n * Hashing: The transaction hash is the BLAKE3 digest of the byte stream from\n   the version field up to and including the final byte of the last Invocation\n   block's instructions field. The SignatureSet and the final EOF marker are\n   excluded from the hash.\n * Signing: For every signing address, a corresponding SignaturePair must be\n   provided. The Ed25519 and SPHINCS-256s signatures are calculated over the\n   transaction hash.\n   \n   Signature verification MUST be performed in index order, matching each\n   SignaturePair to the corresponding address in the addresses vector, starting\n   from index 0.\n\n--------------------------------------------------------------------------------\n\n\nRationale#\n\n * Flexible Invocations: The repeating block structure for invocations allows\n   for complex transactions that can interact with multiple programs in a single\n   atomic unit.\n * Implicit Signer Count: Deriving the number of signers from the number of\n   SignaturePair blocks simplifies parsing and removes the need for a separate\n   field to declare the signer count.\n * Unified Address List: A single addresses vector simplifies address management\n   and indexing for invocations.\n * Dual Signatures: Requiring both Ed25519 and SPHINCS-256s (a PQC algorithm)\n   signatures provides both high performance for standard validation and\n   long-term security against quantum attacks.\n * SCTP Base: Building on LIP-6, this ensures that the low-level encoding is\n   consistent with the rest of the protocol.\n\n--------------------------------------------------------------------------------\n\n\nBackwards Compatibility#\n\nThis LIP defines a new, foundational application-layer standard. It does not\nreplace a previously defined transaction format LIP. As such, it does not\nintroduce a backwards compatibility break in the LIP process, but its adoption\nis a mandatory and breaking change for any client or node software wishing to\ninteract with the LEA network, in conjunction with the adoption of LIP-6.\n\n--------------------------------------------------------------------------------\n\n\nSecurity Considerations#\n\n * Hashing Integrity: Validators MUST strictly adhere to the specified hashing\n   protocol. Including any part of the SignatureSet in the hash would invalidate\n   all signatures.\n * Signature Verification: For each SignaturePair, both the Ed25519 and\n   SPHINCS-256s signatures must be successfully verified against the transaction\n   hash using the public key of the corresponding signing address. A failure in\n   either verification invalidates the transaction.\n * Index-out-of-Bounds: Parsers MUST validate that each targetIndex in an\n   invocation is a valid index within the addresses vector. An invalid index\n   must cause the transaction to be rejected.\n * Vector Length Validation: Parsers MUST validate that the addresses vector\n   length is a multiple of 32 and that the signature vectors have the correct\n   fixed lengths (64 and 29792). Failure to do so could lead to buffer overflows\n   or incorrect data interpretation.\n * Fee Payer: The first entry in the addresses vector is the fee payer. Logic\n   for deducting fees must correctly and exclusively identify this address.\n\n--------------------------------------------------------------------------------\n\n\nCopyright#\n\nThis LIP is licensed under the MIT License, in alignment with the main LEA\nProject License.","routePath":"/lips/LIP-0007","lang":"","toc":[{"text":"Abstract","id":"abstract","depth":2,"charIndex":165},{"text":"Motivation","id":"motivation","depth":2,"charIndex":641},{"text":"Specification","id":"specification","depth":2,"charIndex":1174},{"text":"Core Type System","id":"core-type-system","depth":3,"charIndex":1376},{"text":"LEA Transaction Format (as interpreted by Genesis Decoder)","id":"lea-transaction-format-as-interpreted-by-genesis-decoder","depth":3,"charIndex":1777},{"text":"Invocation Block","id":"invocation-block","depth":3,"charIndex":2602},{"text":"SignaturePair Block","id":"signaturepair-block","depth":3,"charIndex":2887},{"text":"Notation Key","id":"notation-key","depth":3,"charIndex":3215},{"text":"Field Constraints and Rules","id":"field-constraints-and-rules","depth":3,"charIndex":3466},{"text":"Hashing and Signing Protocol","id":"hashing-and-signing-protocol","depth":3,"charIndex":5176},{"text":"Rationale","id":"rationale","depth":2,"charIndex":5902},{"text":"Backwards Compatibility","id":"backwards-compatibility","depth":2,"charIndex":6800},{"text":"Security Considerations","id":"security-considerations","depth":2,"charIndex":7292},{"text":"Copyright","id":"copyright","depth":2,"charIndex":8490}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"","content":" * LIP: 8\n * Layer: Application\n * Title: LEA WebAssembly VM's Supported Features\n * Author: Allwin Ketnawang\n * Created: 2025-07-11\n * Status: Draft\n\n\nAbstract#\n\nThis LIP provides a technical explanation of the supported and unsupported\nWebAssembly (WASM) features in the LEA Virtual Machine. It clarifies which\nfeatures are enabled to ensure deterministic execution and high security, and\nwhich are disabled to prevent non-determinism and potential consensus failures.\nThis document serves as a guide for developers building applications on the LEA\nplatform.\n\n\nMotivation#\n\nThe LEA WebAssembly (WASM) Virtual Machine is a specialized runtime designed for\nenvironments that demand high security and deterministic execution, LEA VM's\nfeature set is tailored to ensure that every operation produces an identical\nresult across all nodes in a network, which is critical for achieving consensus.\nA clear specification of supported features is necessary for developers to build\ncompatible and secure smart contracts.\n\n\nSpecification#\n\nBased on the requirements for determinism and security, the LEA VM supports a\ncore set of stable, deterministic WebAssembly features while actively disabling\nexperimental or non-deterministic ones.\n\n\nSupported and Recommended Features#\n\nThe LEA VM is optimized for safety and predictability. The following WebAssembly\nfeatures are considered safe and are supported:\n\n * -mbulk-memory: This feature is fully supported. It provides highly efficient\n   methods for managing and manipulating large blocks of memory, such as\n   memory.copy and memory.fill. These operations are deterministic and\n   significantly improve performance for memory-intensive tasks without\n   compromising consensus.\n\n * -msign-ext: Support for sign-extension operations is included. This allows\n   for the correct and predictable conversion between integer types of different\n   sizes (e.g., from an 8-bit integer to a 32-bit integer), which is a\n   fundamental and stable part of the WebAssembly specification.\n\n * -mmultivalue: The LEA VM supports returning multiple values from a single\n   function. This is a widely adopted and stable feature that helps developers\n   write cleaner and more efficient code. For example, a function in Rust\n   returning a tuple (i32, i32) will compile correctly. To ensure this works\n   when compiling with Clang-based tools (like rustc), the compiler must be\n   configured with the appropriate ABI flags (-Xclang -target-abi -Xclang\n   experimental-mv).\n\n\nUnsupported and Discouraged Features#\n\nTo maintain determinism and security, the LEA VM explicitly avoids features that\ncould introduce unpredictable behavior or security risks. The following are not\nsupported:\n\n * -msimd128: SIMD (Single Instruction, Multiple Data) operations are disabled.\n   While powerful for multimedia and scientific computing, their results can\n   vary subtly across different CPU architectures, making them unsuitable for\n   consensus-critical applications.\n\n * -matomics: Threading and atomic operations are not supported. Blockchain\n   smart contracts are single-threaded by design. Introducing atomics or shared\n   memory would break this model and introduce significant complexity and\n   consensus risks.\n\n * -mnontrapping-fptoint: This feature, which prevents crashes on invalid\n   floating-point to integer conversions, is disabled. In a deterministic\n   system, such invalid operations must be handled as explicit, predictable\n   traps (errors) rather than producing a default value, which could lead to\n   state divergence.\n\n * Experimental Proposals: Any features that are still experimental or subject\n   to change are not supported. This includes:\n   \n   * -mreference-types: Introduces garbage collection and complex reference\n     handling, which are not yet considered deterministic or secure enough for\n     blockchain VMs.\n   * -mtail-call: A proposal for optimizing function calls that has unclear and\n     potentially non-deterministic behavior regarding the call stack.\n\n\nRationale#\n\nThe selection of WASM features is strictly guided by the core requirements of a\nblockchain environment: determinism, security, and consensus. The enabled\nfeatures (bulk-memory, sign-ext, multivalue) are all stable, well-defined, and\nguaranteed to produce identical results on any compliant hardware. Features like\nSIMD and atomics are disabled because they can introduce implementation-defined\nbehavior or break the single-threaded execution model, which would make it\nimpossible to guarantee consensus. By restricting the VM to a core, stable, and\ndeterministic subset of WebAssembly, the LEA platform ensures a robust and\nsecure foundation for smart contracts.\n\n\nBackwards Compatibility#\n\nThis LIP is purely informational and defines the capabilities of the LEA VM. It\ndoes not introduce any backwards compatibility issues with the LEA protocol\nitself.\n\n\nSecurity Considerations#\n\nThe feature set described in this LIP is fundamental to the security model of\nthe LEA platform. By disabling non-deterministic and experimental features, the\nVM reduces the attack surface and prevents a class of vulnerabilities related to\nstate divergence and consensus splits. Adherence to this specified feature set\nis critical for maintaining the security and integrity of all applications\nrunning on the LEA network.\n\n\nCopyright#\n\nThis LIP is licensed under the MIT License, in alignment with the main LEA\nProject License.","routePath":"/lips/LIP-0008","lang":"","toc":[{"text":"Abstract","id":"abstract","depth":2,"charIndex":151},{"text":"Motivation","id":"motivation","depth":2,"charIndex":562},{"text":"Specification","id":"specification","depth":2,"charIndex":1013},{"text":"Supported and Recommended Features","id":"supported-and-recommended-features","depth":3,"charIndex":1229},{"text":"Unsupported and Discouraged Features","id":"unsupported-and-discouraged-features","depth":3,"charIndex":2496},{"text":"Rationale","id":"rationale","depth":2,"charIndex":4012},{"text":"Backwards Compatibility","id":"backwards-compatibility","depth":2,"charIndex":4689},{"text":"Security Considerations","id":"security-considerations","depth":2,"charIndex":4881},{"text":"Copyright","id":"copyright","depth":2,"charIndex":5330}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"LEA Improvement Proposals (LIPs) Index","content":"#\n\nThis table provides an overview and status of the current LIPs for the LEA\nproject.\n\nNUMBER   LAYER           TITLE                                                         OWNER (AUTHOR)     STATUS\n1        Core Encoding   Extend Tag 10 for Sub-Typed Data (IxData Field)               Allwin Ketnawang   Replaced\n2        Core Encoding   Typed Crypto Schemes and Segregated PQC Signature Proofs      Allwin Ketnawang   Replaced\n3        Meta/Process    LIP Structure and Process                                     Allwin Ketnawang   Proposed\n4        Core Encoding   Decouple Legacy Index Field from List Context                 Allwin Ketnawang   Replaced\n5        Core Encoding   Generalize Vectors with Explicit Entry Sizes                  Allwin Ketnawang   Replaced\n6        Core Encoding   Replace Core Transaction Encoding (CTE) with Simple Compact   Allwin Ketnawang   Proposed\n                         Transaction Protocol (SCTP)\n7        Application     Genesis LEA Transaction Decoder Format                        Allwin Ketnawang   Draft\n8        Application     LEA WebAssembly VM's Supported Features                       Allwin Ketnawang   Draft","routePath":"/lips/README","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"LEA Improvement Proposals (LIPs) Index","content":"#\n\nThis page provides an overview of the current and active LEA Improvement\nProposals.\n\nNUMBER     TITLE                                                         LAYER           STATUS\nLIP-0003   LIP Structure and Process                                     Meta/Process    Proposed\nLIP-0006   Replace Core Transaction Encoding (CTE) with Simple Compact   Core Encoding   Proposed\n           Transaction Protocol (SCTP)\nLIP-0007   Genesis LEA Transaction Decoder Format                        Application     Draft\nLIP-0008   LEA WebAssembly VM's Supported Features                       Application     Draft","routePath":"/lips/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"LTM Module Usage","content":"ltm#\n\nNode.js module for programmatically building and decoding Lea Chain Transaction\nManifests.\n\n\nLTM Module Usage#\n\nThis guide provides detailed instructions and examples for using the ltm package\nas a Node.js module.\n\n\nInstallation#\n\nInstall the package using npm:\n\n\n\n--------------------------------------------------------------------------------\n\n\nCore Functions#\n\nThe module exports two primary asynchronous functions: build and decode.\n\n\n\n--------------------------------------------------------------------------------\n\n\n1. build(ltmObject)#\n\nProgrammatically constructs and signs a binary transaction from a JavaScript\nobject.\n\n * Parameter: ltmObject (Object) - A JavaScript object that follows the LTM\n   schema. Note: The outputFile field is ignored by this function.\n * Returns: A Promise that resolves to a Uint8Array containing the raw binary\n   transaction data.\n\nImportant Note on Browser Usage#\n\nThe build function has limitations in a browser environment. Specifically, any\nLTM feature that requires file system access or command execution will not work.\nThis includes:\n\n * The signers object (which reads key files).\n * The $file(), $json(), and $exec() placeholders.\n\nIf these features are used in a browser context, the function will throw an\nerror. To build transactions in a browser, you must provide all data, including\nkey material, directly within the ltmObject.\n\nExample: Building a Transaction in Node.js#\n\nThis example demonstrates building a transaction by providing the keyset\ndirectly as a JavaScript array.\n\n\n\n--------------------------------------------------------------------------------\n\n\n2. decode(binaryData)#\n\nDecodes a binary transaction into a human-readable JavaScript object. This\nfunction is universal and works the same in both Node.js and browser\nenvironments.\n\n * Parameter: binaryData (Buffer | Uint8Array) - The binary transaction data to\n   decode.\n * Returns: A Promise that resolves to a JavaScript object representing the\n   transaction.\n\nExample: Decoding a Transaction#\n\nThis example reads a binary transaction file and prints its decoded contents.\n\n\n\n--------------------------------------------------------------------------------","routePath":"/npm-module/generated/ltm","lang":"","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":221},{"text":"Core Functions","id":"core-functions","depth":2,"charIndex":353},{"text":"1. `build(ltmObject)`","id":"1-buildltmobject","depth":3,"charIndex":-1},{"text":"Important Note on Browser Usage","id":"important-note-on-browser-usage","depth":4,"charIndex":880},{"text":"Example: Building a Transaction in Node.js","id":"example-building-a-transaction-in-nodejs","depth":4,"charIndex":1391},{"text":"2. `decode(binaryData)`","id":"2-decodebinarydata","depth":3,"charIndex":-1},{"text":"Example: Decoding a Transaction","id":"example-decoding-a-transaction","depth":4,"charIndex":1994}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"NPM Modules","content":"#\n\nThis section provides documentation for the official NPM modules used to\ninteract with the LEA Chain.","routePath":"/npm-module/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"`lea-keygen` Command-Line Usage","content":"lea-keygen#\n\nA CLI tool for generating and managing Lea Chain keysets.\n\n\nlea-keygen Command-Line Usage#\n\nThis guide provides detailed instructions for using the lea-keygen command-line\ntool to generate Lea Chain keysets.\n\n\nInstallation#\n\nFor one-off commands, you can use npx without any installation:\n\n\n\nAlternatively, you can install it globally to use the lea-keygen command\ndirectly:\n\n\n\n--------------------------------------------------------------------------------\n\n\nCommands#\n\nThe lea-keygen tool supports two main commands: new and verify.\n\n\nnew Command#\n\nGenerates a new keyset.\n\nSynopsis#\n\n\n\nOptions#\n\n * --no-outfile: Prints the generated keyset to standard output (stdout) as a\n   JSON array instead of saving it to a file.\n * --outfile <path>: Specifies a custom file path to save the keyset. If this is\n   not provided, the keyset is saved to <address>.json in the current directory.\n * --force: If a keyset file already exists at the target path, this flag allows\n   overwriting it. Without this flag, the tool will exit with an error to\n   prevent accidental data loss.\n\nExamples#\n\n1. Generate a Keyset and Save to a File#\n\nThis is the default behavior. It generates a new keyset and saves it to a file\nnamed after the derived public address.\n\nCommand:\n\n\n\nOutput (to stderr):\n\n\n\nThe resulting file will contain the full keyset with secure file permissions\n(600).\n\n2. Generate a Keyset and Print to Console#\n\nUse the --no-outfile flag to prevent writing to a file and instead print the\nkeyset to stdout.\n\nCommand:\n\n\n\nOutput (to stdout):\n\n\n\nOutput (to stderr):\n\n\n\n--------------------------------------------------------------------------------\n\n\nverify Command#\n\nDisplays the public address for a given keyset file.\n\nSynopsis#\n\n\n\n * <file_path>: The path to the keyset JSON file.\n\nDescription#\n\nThis command reads a keyset file, derives the public address from it, and prints\nthe address to standard output. This is useful for verifying the address of a\nwallet without needing to generate a new key.\n\nExample#\n\nCommand:\n\n\n\nOutput (to stdout):\n\n\n\n--------------------------------------------------------------------------------","routePath":"/tools/generated/lea-keygen","lang":"","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":222},{"text":"Commands","id":"commands","depth":2,"charIndex":473},{"text":"`new` Command","id":"new-command","depth":3,"charIndex":-1},{"text":"Synopsis","id":"synopsis","depth":4,"charIndex":589},{"text":"Options","id":"options","depth":4,"charIndex":602},{"text":"Examples","id":"examples","depth":4,"charIndex":1087},{"text":"`verify` Command","id":"verify-command","depth":3,"charIndex":-1},{"text":"Synopsis","id":"synopsis-1","depth":4,"charIndex":1732},{"text":"Description","id":"description","depth":4,"charIndex":1796},{"text":"Example","id":"example","depth":4,"charIndex":2016}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"LTM Command-Line Usage","content":"ltm#\n\nCommand-line interface for building and decoding Lea Chain Transaction\nManifests.\n\n\nLTM Command-Line Usage#\n\nThis guide provides detailed instructions for using the ltm command-line tool.\n\n\nInstallation#\n\nFor one-off commands, you can use npx without any installation:\n\n\n\nAlternatively, you can install it globally to use the ltm command directly:\n\n\n\n--------------------------------------------------------------------------------\n\n\nCommands#\n\nThe CLI has two main commands: build and decode.\n\n\n1. build#\n\nConstructs and signs a binary transaction from a JSON-based LTM file.\n\nSynopsis#\n\n\n\n * <file_path>: The path to your LTM JSON file.\n\nDescription#\n\nThe build command reads a specified LTM file, resolves all placeholders,\nassembles the transaction, and signs it.\n\nIf the outputFile field is present in the manifest, the binary data is written\nto that file. If outputFile is omitted, the raw binary data is written to\nstandard output (stdout), allowing it to be piped to other tools.\n\nExample 1: Writing to a File#\n\nIf my-transaction.json contains an outputFile field, the output is saved to that\nfile. This example also shows loading signers using placeholders.\n\n\n\nCommand Execution:\n\n\n\nOutput (to stderr):\n\n\n\nExample 2: Piping to Standard Output#\n\nIf stdout-transaction.json omits the outputFile field, the output is piped to\nstdout.\n\n\n\nCommand Execution:\n\n\n\nOutput (to stdout): The raw binary data of the transaction. (The example above\nshows it being piped to the decode command).\n\n--------------------------------------------------------------------------------\n\n\n2. decode#\n\nDecodes a binary transaction into a human-readable JSON format.\n\nSynopsis#\n\n\n\n * <file_path>: The path to the binary transaction file. Use - to read from\n   standard input (stdin).\n\nDescription#\n\nThis command is the reverse of build. It reads a binary transaction from a file\nor standard input and writes the decoded JSON representation to standard output\n(stdout). It is useful for verifying the contents of a binary transaction before\nbroadcasting it.\n\nExample#\n\nCommand Execution:\n\n\n\nOutput (example format):\n\n\n\n--------------------------------------------------------------------------------","routePath":"/tools/generated/ltm","lang":"","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":195},{"text":"Commands","id":"commands","depth":2,"charIndex":439},{"text":"1. `build`","id":"1-build","depth":3,"charIndex":-1},{"text":"Synopsis","id":"synopsis","depth":4,"charIndex":583},{"text":"Description","id":"description","depth":4,"charIndex":645},{"text":"Example 1: Writing to a File","id":"example-1-writing-to-a-file","depth":4,"charIndex":994},{"text":"Example 2: Piping to Standard Output","id":"example-2-piping-to-standard-output","depth":4,"charIndex":1220},{"text":"2. `decode`","id":"2-decode","depth":3,"charIndex":-1},{"text":"Synopsis","id":"synopsis-1","depth":4,"charIndex":1655},{"text":"Description","id":"description-1","depth":4,"charIndex":1772},{"text":"Example","id":"example","depth":4,"charIndex":2045}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"Tools","content":"#\n\nThis section provides documentation for the various command-line tools and\nutilities available for the LEA Chain ecosystem.","routePath":"/tools/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]