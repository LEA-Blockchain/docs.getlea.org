"use strict";(self.webpackChunkrspress=self.webpackChunkrspress||[]).push([["249"],{4942:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var r=s(5893),i=s(65);function t(e){let n=Object.assign({ul:"ul",li:"li",strong:"strong",h2:"h2",a:"a",p:"p",code:"code",h3:"h3",pre:"pre"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"LIP: 12"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Layer: Application"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Title: LEA Keyset File Format"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Author: Allwin Ketnawang"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Created: 2025-07-16"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Status: Proposed"})}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"abstract",children:["Abstract",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#abstract",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"This LIP defines a standard JSON-based file format for storing the cryptographic keys required for a LEA account. The format encapsulates the Ed25519 secret key and the SPHINCS+ secret and public keys into a structured, compact, and machine-readable file. The primary goal is to ensure interoperability between different wallets, tools, and applications within the LEA ecosystem."}),"\n",(0,r.jsxs)(n.h2,{id:"motivation",children:["Motivation",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#motivation",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"To interact with the Lea network, a user must manage a set of cryptographic keys. Without a standardized format for storing these keys, each application (e.g., CLI tools, wallets, libraries) would be forced to implement its own proprietary storage method. This would lead to a fragmented ecosystem where users cannot easily move their accounts between different tools, increasing friction and the risk of key handling errors."}),"\n",(0,r.jsxs)(n.p,{children:["By defining a single, clear standard, this LIP ensures that a keyset generated by one tool (like ",(0,r.jsx)(n.code,{children:"lea-keygen"}),") can be seamlessly used by any other compliant tool (like the ",(0,r.jsx)(n.code,{children:"ltm"})," builder). This promotes interoperability, simplifies development, and improves the overall user experience."]}),"\n",(0,r.jsxs)(n.h2,{id:"specification",children:["Specification",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#specification",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"A LEA Keyset file is a JSON file containing a single top-level array. The structure is defined as follows:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Root:"})," A JSON Array with two elements."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Element 1: Ed25519 Secret Key"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type:"})," ",(0,r.jsx)(n.code,{children:"Array<number>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description:"})," An array of 64 integers, where each integer represents a byte of the Ed25519 secret key. The public key is implicitly the last 32 bytes of this secret key."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Element 2: SPHINCS+ Keyset"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type:"})," ",(0,r.jsx)(n.code,{children:"Array"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description:"})," A nested array containing the SPHINCS+ secret and public keys.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Element 2.1: SPHINCS+ Secret Key"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type:"})," ",(0,r.jsx)(n.code,{children:"Array<number>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description:"})," An array of 64 integers representing the bytes of the SPHINCS+ secret key."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Element 2.2: SPHINCS+ Public Key"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type:"})," ",(0,r.jsx)(n.code,{children:"Array<number>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description:"})," An array of 32 integers representing the bytes of the SPHINCS+ public key."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"json-structure-example",children:["JSON Structure Example",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#json-structure-example",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"[\n  // Element 1: Ed25519 Secret Key (64 bytes)\n  [ 1, 2, 3, ..., 64 ],\n\n  // Element 2: SPHINCS+ Keyset\n  [\n    // Element 2.1: SPHINCS+ Secret Key (64 bytes)\n    [ 101, 102, 103, ..., 164 ],\n\n    // Element 2.2: SPHINCS+ Public Key (32 bytes)\n    [ 201, 202, 203, ..., 232 ]\n  ]\n]\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"rationale",children:["Rationale",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rationale",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"JSON as a Base:"})," JSON is a universally supported, human-readable format, making it an ideal choice for a simple key storage standard."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Array of Arrays:"})," This structure was chosen for its compactness and strict ordering. Compared to a JSON object with named keys, it reduces file size and removes ambiguity about property names. The fixed positions of each key make parsing simple and efficient."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Array of Integers for Binary Data:"})," Representing raw binary data as an array of byte-sized integers (0-255) is a standard, language-agnostic method that avoids the overhead and complexity of Base64 or hex string encoding within the JSON file itself."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"backwards-compatibility",children:["Backwards Compatibility",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#backwards-compatibility",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"This is a new, additive standard. It does not break any existing protocol rules or formats and will serve as the standard for all tools created after its acceptance."}),"\n",(0,r.jsxs)(n.h2,{id:"security-considerations",children:["Security Considerations",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#security-considerations",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"This file contains unencrypted private keys and is extremely sensitive."})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"File Permissions:"})," Any tool that creates a LEA Keyset file (e.g., ",(0,r.jsx)(n.code,{children:"lea-keygen"}),") ",(0,r.jsx)(n.strong,{children:"MUST"})," set the file permissions to ",(0,r.jsx)(n.code,{children:"0o600"})," (user-read-write only) to prevent unauthorized access by other users on the same system."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parsing:"})," A compliant parser ",(0,r.jsx)(n.strong,{children:"MUST"})," validate the structure of the file, including the presence and lengths of all arrays, to prevent errors and potential vulnerabilities from malformed keyset files."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"copyright",children:["Copyright",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#copyright",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"This LIP is licensed under the MIT License."})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let l=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["lips%2FLIP-0012.md"]={toc:[{text:"Abstract",id:"abstract",depth:2},{text:"Motivation",id:"motivation",depth:2},{text:"Specification",id:"specification",depth:2},{text:"JSON Structure Example",id:"json-structure-example",depth:3},{text:"Rationale",id:"rationale",depth:2},{text:"Backwards Compatibility",id:"backwards-compatibility",depth:2},{text:"Security Considerations",id:"security-considerations",depth:2},{text:"Copyright",id:"copyright",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);