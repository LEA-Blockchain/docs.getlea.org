"use strict";(self.webpackChunkrspress=self.webpackChunkrspress||[]).push([["105"],{1189:function(e,n,i){i.r(n),i.d(n,{default:()=>o});var s=i(5893),r=i(65);function t(e){let n=Object.assign({ul:"ul",li:"li",strong:"strong",h2:"h2",a:"a",p:"p",h3:"h3",code:"code",h4:"h4"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"LIP: 11"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Layer: Application"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Title: LEA Public Key Module Interface (LEA-PKMI)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Author: Allwin Ketnawang"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Created: 2025-07-16"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Status: Proposed"})}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"abstract",children:["Abstract",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#abstract",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"This LIP defines a standard interface for WebAssembly (WASM) modules that provide public-key cryptography functions. The LEA Public Key Module Interface (LEA-PKMI) specifies a set of required imports and exports that enable seamless integration of cryptographic modules for operations like key generation, signing, and verification within the LEA ecosystem. This standardization promotes interoperability, simplifies development, and allows for modular replacement of cryptographic implementations."}),"\n",(0,s.jsxs)(n.h2,{id:"motivation",children:["Motivation",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#motivation",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:'As the LEA ecosystem grows, there is a need for a standardized way to perform public-key cryptography across different applications and environments. Without a defined interface, developers must write custom "glue code" for each specific cryptographic library, leading to duplicated effort, increased complexity, and a higher risk of implementation errors.'}),"\n",(0,s.jsx)(n.p,{children:"The LEA-PKMI provides a clear, minimal, and efficient contract between a host environment and a WASM-based cryptographic module. This allows developers to easily swap different modules (e.g., switching from an Ed25519 module to a different signature scheme) without changing the host application's code, fostering a more flexible and secure development environment."}),"\n",(0,s.jsxs)(n.h2,{id:"specification",children:["Specification",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#specification",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Any WASM module compliant with LEA-PKMI MUST implement the following interface."}),"\n",(0,s.jsxs)(n.h3,{id:"1-imports",children:["1. Imports",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-imports",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["The module MUST import the following functions from the host environment under the ",(0,s.jsx)(n.code,{children:"env"})," namespace."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"__lea_abort(line: i32)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": Called by the module to signal a fatal, unrecoverable error."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"line"}),": A 32-bit integer representing the source code line number where the error occurred."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Host Action"}),": The host must terminate the execution environment."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"__lea_randombytes(ptr: i32, len: i32)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": Called by the module to request cryptographically secure random data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ptr"}),": A 32-bit integer representing the memory address where the host should write the random data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"len"}),": A 32-bit integer specifying the number of bytes to write."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Host Action"}),": The host must fill the module's linear memory at ",(0,s.jsx)(n.code,{children:"ptr"})," with ",(0,s.jsx)(n.code,{children:"len"})," bytes of secure random data."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-exports",children:["2. Exports",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-exports",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"The module MUST export the following memory and functions."}),"\n",(0,s.jsxs)(n.h4,{id:"21-memory",children:["2.1. Memory",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-memory",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"memory: WebAssembly.Memory"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": The module's linear memory. The host uses this to write input data (e.g., messages) and read output data (e.g., keys, signatures)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"22-allocator-functions",children:["2.2. Allocator Functions",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-allocator-functions",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"__lea_malloc(size: i32): i32"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": Allocates a memory block of ",(0,s.jsx)(n.code,{children:"size"})," bytes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),": A pointer to the start of the allocated block."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"__lea_allocator_reset()"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": Resets the module's internal allocator, invalidating all pointers."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"23-constant-functions",children:["2.3. Constant Functions",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-constant-functions",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"pk_bytes(): i32"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),": The required size in bytes for a public key."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"sk_bytes(): i32"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),": The required size in bytes for a secret key."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"signature_bytes(): i32"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),": The required size in bytes for a signature."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"24-cryptographic-functions",children:["2.4. Cryptographic Functions",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-cryptographic-functions",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["These functions MUST return ",(0,s.jsx)(n.code,{children:"0"})," on success and a non-zero integer on failure."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"keygen(pk_ptr: i32, sk_ptr: i32): i32"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": Generates a new key pair."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pk_ptr"}),": Pointer to an allocated block for the public key."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sk_ptr"}),": Pointer to an allocated block for the secret key."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"sign(sig_ptr: i32, msg_ptr: i32, msg_len: i32, sk_ptr: i32): i32"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": Signs a message with a secret key."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sig_ptr"}),": Pointer to an allocated block for the output signature."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"msg_ptr"}),": Pointer to the message to be signed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"msg_len"}),": The length of the message."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sk_ptr"}),": Pointer to the secret key."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"verify(sig_ptr: i32, msg_ptr: i32, msg_len: i32, pk_ptr: i32): i32"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description"}),": Verifies a signature against a message and public key."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sig_ptr"}),": Pointer to the signature to verify."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"msg_ptr"}),": Pointer to the original message."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"msg_len"}),": The length of the message."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pk_ptr"}),": Pointer to the public key."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"rationale",children:["Rationale",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rationale",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"The design of the LEA-PKMI prioritizes simplicity, security, and performance."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimalism"}),": The interface exposes only the essential functions required for public-key cryptography. This simplifies host-side integration by providing a clear and focused set of operations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Language Agnostic"}),": By using only 32-bit integer types (",(0,s.jsx)(n.code,{children:"i32"}),"), the interface remains compatible with any host language that can interact with WebAssembly, avoiding complexities of higher-level data types."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Explicit Memory Management"}),": The host controls memory allocation via ",(0,s.jsx)(n.code,{children:"__lea_malloc"})," and can reset the state with ",(0,s.jsx)(n.code,{children:"__lea_allocator_reset"}),". This simple model avoids the need for complex memory management or garbage collection schemes across the WASM boundary."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Host-Provided Randomness"}),": The module relies on the host for random data via ",(0,s.jsx)(n.code,{children:"__lea_randombytes"}),". This is a critical security decision, as generating secure randomness is a responsibility best handled by the host environment, which has direct access to system-level entropy sources."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"backwards-compatibility",children:["Backwards Compatibility",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#backwards-compatibility",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"This LIP introduces a new standard and does not break any existing protocols. It is intended for new cryptographic modules developed for the LEA ecosystem. Existing modules would need to be updated to comply with this interface."}),"\n",(0,s.jsxs)(n.h2,{id:"security-considerations",children:["Security Considerations",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#security-considerations",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Host Responsibilities"}),": The host environment is responsible for providing a cryptographically secure random number generator (CSPRNG) for the ",(0,s.jsx)(n.code,{children:"__lea_randombytes"})," import. A weak or predictable source of randomness will compromise all cryptographic operations. The host must also handle the ",(0,s.jsx)(n.code,{children:"__lea_abort"})," call by safely terminating the process to prevent further execution in a potentially corrupt state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Module Responsibilities"}),": The WASM module is a security-critical component. It must be carefully implemented and audited to ensure it is free of vulnerabilities. The module should perform all necessary input validation and operate with constant-time algorithms where appropriate to prevent side-channel attacks."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interface Security"}),": The interface itself is designed to be simple, reducing the potential for misuse. By passing data via pointers, it avoids copying large amounts of data across the WASM boundary, which can be a source of both performance issues and vulnerabilities."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"copyright",children:["Copyright",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#copyright",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"This LIP is licensed under the MIT License."})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let o=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["lips%2FLIP-0011.md"]={toc:[{text:"Abstract",id:"abstract",depth:2},{text:"Motivation",id:"motivation",depth:2},{text:"Specification",id:"specification",depth:2},{text:"1. Imports",id:"1-imports",depth:3},{text:"2. Exports",id:"2-exports",depth:3},{text:"2.1. Memory",id:"21-memory",depth:4},{text:"2.2. Allocator Functions",id:"22-allocator-functions",depth:4},{text:"2.3. Constant Functions",id:"23-constant-functions",depth:4},{text:"2.4. Cryptographic Functions",id:"24-cryptographic-functions",depth:4},{text:"Rationale",id:"rationale",depth:2},{text:"Backwards Compatibility",id:"backwards-compatibility",depth:2},{text:"Security Considerations",id:"security-considerations",depth:2},{text:"Copyright",id:"copyright",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);