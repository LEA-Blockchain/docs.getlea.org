"use strict";(self.webpackChunkrspress=self.webpackChunkrspress||[]).push([["268"],{5714:function(e,n,i){i.r(n),i.d(n,{default:()=>d});var s=i(5893),r=i(65);function t(e){let n=Object.assign({ul:"ul",li:"li",strong:"strong",h2:"h2",a:"a",p:"p",h3:"h3",code:"code",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",pre:"pre",ol:"ol",h4:"h4",em:"em"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"LIP: 10"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Layer: Application"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Title: LEA Transaction Manifest (LTM)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Author: Allwin Ketnawang"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Created: 2025-07-15"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Requires: 7"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Status: Proposed"})}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"abstract",children:["Abstract",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#abstract",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"This LIP proposes the LEA Transaction Manifest (LTM), a standardized, declarative JSON format for defining LEA transactions. The LTM schema is designed to abstract away the complexities of binary serialization, allowing developers and users to define complex transactions in a human-readable and reusable manner. It provides a robust system for sourcing data dynamically from the local file system and other data structures. The primary goal of LTM is to make transaction creation simpler, safer, and more transparent, separating the definition of a transaction's data from the logic of its binary encoding."}),"\n",(0,s.jsxs)(n.h2,{id:"motivation",children:["Motivation",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#motivation",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"The process of creating a valid LEA transaction, as defined in LIP-7, requires precise binary encoding using the Simple Compact Transaction Protocol (SCTP). Constructing this binary stream programmatically is a low-level task that is verbose, error-prone, and requires custom scripting for each new type of transaction. This approach tightly couples the transaction's data with the application logic, making it difficult to manage, reuse, or audit transaction definitions."}),"\n",(0,s.jsx)(n.p,{children:"The LEA Transaction Manifest (LTM) introduces a declarative layer that solves this problem. By defining a transaction in a structured JSON format, users can clearly specify all its components (such as signers, gas parameters, and contract invocations) without writing any encoding logic. The LTM format is designed to be processed by a build tool that handles all the underlying complexities of data resolution, SCTP encoding, hashing, and signing. This separation of concerns dramatically simplifies the user experience, reduces the risk of malformed transactions, and promotes the creation of reusable transaction templates."}),"\n",(0,s.jsxs)(n.h2,{id:"specification",children:["Specification",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#specification",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"A LEA Transaction Manifest is a JSON file that adheres to the following structure. The file must be parsed by a tool that can safely handle large integers to prevent precision loss."}),"\n",(0,s.jsxs)(n.h3,{id:"1-top-level-structure",children:["1. Top-Level Structure",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-top-level-structure",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["The LTM is a single JSON object with the following root fields. The ",(0,s.jsx)(n.code,{children:"version"})," field, specified as the first field in the LIP-7 binary format, is intentionally excluded. The build tool that processes the manifest is responsible for automatically prepending the protocol version (",(0,s.jsx)(n.code,{children:"1"}),") during binary serialization."]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{align:"left",children:"Field"}),"\n",(0,s.jsx)(n.th,{align:"left",children:"Type"}),"\n",(0,s.jsx)(n.th,{align:"left",children:"Required"}),"\n",(0,s.jsx)(n.th,{align:"left",children:"Description"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"sequence"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Number or String"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Yes"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"The sequence number (nonce) for the fee-paying signer."}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"feePayer"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"String"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Yes"}),"\n",(0,s.jsxs)(n.td,{align:"left",children:["The name of the signer who will pay the transaction fees. Must match a key in the ",(0,s.jsx)(n.code,{children:"signers"})," object."]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"gasLimit"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Number or String"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Yes"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"The maximum gas units the transaction can consume."}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"gasPrice"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Number or String"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Yes"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"The price per gas unit."}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"outputFile"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"String"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"No"}),"\n",(0,s.jsxs)(n.td,{align:"left",children:["The file path where the final binary transaction will be written. If omitted when using the CLI, the binary output is written to ",(0,s.jsx)(n.code,{children:"stdout"}),". This field is ignored when used as a module."]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"constants"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Object"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"No"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"An object defining reusable values that can be referenced elsewhere in the manifest."}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"signers"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Object"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Yes"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"An object defining the one or more signers for the transaction."}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"invocations"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Array"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Yes"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"An array of one or more invocation objects."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-signers-object",children:["2. ",(0,s.jsx)(n.code,{children:"signers"})," Object",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-signers-object",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"signers"})," object contains one or more key-value pairs, where each key is a unique, user-defined name for the signer (e.g., ",(0,s.jsx)(n.code,{children:"mainAccount"}),", ",(0,s.jsx)(n.code,{children:"alice"}),"). This name is used to reference the signer in the ",(0,s.jsx)(n.code,{children:"feePayer"})," field and in ",(0,s.jsx)(n.code,{children:"$signer()"})," placeholders."]}),"\n",(0,s.jsx)(n.p,{children:"The value for each signer can be one of two types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"File Path (String):"})," A string containing the relative path to a LEA Keyset file. The file ",(0,s.jsx)(n.strong,{children:"MUST"})," conform to the format defined in ",(0,s.jsx)(n.strong,{children:"LIP-12: LEA Keyset File Format"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keyset Object (Array):"})," A direct JSON array conforming to the LIP-12 keyset structure. This is primarily for programmatic use when the LTM is used as a library/module."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A build tool resolves these values to load the cryptographic keys needed for signing."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"signers": {\n  "alice": "./keys/alice.keyset.json",\n  "bob": "./keys/bob.keyset.json",\n  "ephemeral": [\n    [ 1, 2, 3, ..., 64 ],\n    [\n      [ 101, 102, 103, ..., 164 ],\n      [ 201, 202, 203, ..., 232 ]\n    ]\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"3-constants-object",children:["3. ",(0,s.jsx)(n.code,{children:"constants"})," Object",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-constants-object",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["This optional top-level object allows you to define key-value pairs for reusable values. These constants can be referenced in other parts of the manifest using the ",(0,s.jsx)(n.code,{children:"$const()"})," placeholder. This is useful for reducing repetition and improving maintainability."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"constants": {\n  "tokenProgram": "a1b2c3d4e5f6...",\n  "USER_REGISTRATION_ID": 5\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"4-invocations-array",children:["4. ",(0,s.jsx)(n.code,{children:"invocations"})," Array",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-invocations-array",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"invocations"})," array contains one or more objects, each representing a single call to a smart contract."]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{align:"left",children:"Field"}),"\n",(0,s.jsx)(n.th,{align:"left",children:"Type"}),"\n",(0,s.jsx)(n.th,{align:"left",children:"Required"}),"\n",(0,s.jsx)(n.th,{align:"left",children:"Description"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"targetAddress"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"String"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Yes"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"The 32-byte hex address of the target contract. Can be a literal or use a placeholder."}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"instructions"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Array"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Yes"}),"\n",(0,s.jsx)(n.td,{align:"left",children:"An array defining the instruction payload to be sent to the target."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"5-address-vector-and-signature-assembly",children:["5. Address Vector and Signature Assembly",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-address-vector-and-signature-assembly",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["A compliant LTM build tool ",(0,s.jsx)(n.strong,{children:"MUST"})," follow a strict, deterministic algorithm to assemble the final ",(0,s.jsx)(n.code,{children:"addresses"})," vector and ",(0,s.jsx)(n.code,{children:"signatures"})," list for the binary transaction defined in LIP-7."]}),"\n",(0,s.jsx)(n.p,{children:"The following algorithm MUST be used:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resolve Placeholders and Collect Addresses:"}),"\na. A build tool MUST first perform a full resolution of all placeholders in the manifest, including chained placeholders (e.g., ",(0,s.jsx)(n.code,{children:"$addr($const(user))"}),"). It MUST detect and fail if a circular dependency is found.\nb. During or after resolution, create a set to store all unique 32-byte addresses required for the transaction. This automatically handles de-duplication as required by LIP-7.\nc. Add the addresses of all signers defined in the ",(0,s.jsx)(n.code,{children:"signers"})," object to the set.\nd. Add the fully-resolved ",(0,s.jsx)(n.code,{children:"targetAddress"})," from each object in the ",(0,s.jsx)(n.code,{children:"invocations"})," array to the set.\ne. Add the fully-resolved address from any ",(0,s.jsx)(n.code,{children:"$addr()"})," placeholder to the set."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identify Fee Payer:"})," The signer name specified in the ",(0,s.jsx)(n.code,{children:"feePayer"})," field is the fee payer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Build the Final ",(0,s.jsx)(n.code,{children:"addresses"})," Vector:"]})," The final vector is assembled using a deterministic, three-tiered sorting algorithm to ensure stability and predictability.\na. ",(0,s.jsx)(n.strong,{children:"Group 1 (Fee Payer):"})," The fee payer's address is the ",(0,s.jsx)(n.strong,{children:"first"})," address in the vector (index 0).\nb. ",(0,s.jsx)(n.strong,{children:"Group 2 (Other Signers):"})," The addresses of all other signers (excluding the fee payer) are sorted amongst themselves based on their 32-byte binary lexicographical value. These are appended to the vector after the fee payer.\nc. ",(0,s.jsx)(n.strong,{children:"Group 3 (Non-Signer Addresses):"})," All remaining unique addresses from the set (i.e., non-signers) are sorted amongst themselves based on their 32-byte binary lexicographical value. These are appended last."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Resolve ",(0,s.jsx)(n.code,{children:"$addr()"})," to Index:"]})," After the final ",(0,s.jsx)(n.code,{children:"addresses"})," vector is constructed, replace every ",(0,s.jsx)(n.code,{children:"$addr()"})," placeholder string with the final numeric index of its corresponding address in the vector. This final number is then encoded according to the instruction's integer type."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The resulting ordered list is the final ",(0,s.jsx)(n.code,{children:"addresses"})," vector for the transaction. The signatures in the binary output MUST correspond to the signer addresses in the exact same order as they appear in the final vector (fee payer first, then the other signers sorted by their binary address)."]}),"\n",(0,s.jsxs)(n.h3,{id:"6-instructions-array",children:["6. ",(0,s.jsx)(n.code,{children:"instructions"})," Array",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-instructions-array",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["This array defines the sequence of data fields that constitute the instruction payload. Each element in the array is an object with a ",(0,s.jsx)(n.strong,{children:"single key"}),", where the key is the SCTP type (e.g., ",(0,s.jsx)(n.code,{children:"vector"}),", ",(0,s.jsx)(n.code,{children:"uleb"}),") and the value is the data to be encoded."]}),"\n",(0,s.jsxs)(n.h3,{id:"7-placeholder-syntax-for-dynamic-data",children:["7. Placeholder Syntax for Dynamic Data",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-placeholder-syntax-for-dynamic-data",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["To enable dynamic data sourcing, LTM values can use a function-like placeholder syntax: ",(0,s.jsx)(n.code,{children:"$<source>(<value>)"}),". Placeholders can be chained (nested), and a build tool MUST support this."]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{align:"left",children:"Placeholder Syntax"}),"\n",(0,s.jsx)(n.th,{align:"left",children:"Example"}),"\n",(0,s.jsx)(n.th,{align:"left",children:"Description"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"$const(<key>)"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:'"$const(tokenProgram)"'})}),"\n",(0,s.jsxs)(n.td,{align:"left",children:["Retrieves a value from the ",(0,s.jsx)(n.code,{children:"constants"})," object."]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"$signer(<name>.<key>)"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:'"$signer(main.address)"'})}),"\n",(0,s.jsxs)(n.td,{align:"left",children:["Retrieves a derived value from a named signer. Valid keys are ",(0,s.jsx)(n.code,{children:"ed25519Pk"}),", ",(0,s.jsx)(n.code,{children:"sphincsPk"}),", and ",(0,s.jsx)(n.code,{children:"address"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"$addr(<source>[#<fmt>])"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:'"$addr($const(user))"'})}),"\n",(0,s.jsxs)(n.td,{align:"left",children:["A special placeholder for integer types (",(0,s.jsx)(n.code,{children:"uleb"}),", ",(0,s.jsx)(n.code,{children:"uint8"}),", etc.) that resolves an address source to its final index in the transaction's address vector. The ",(0,s.jsx)(n.code,{children:"<source>"})," can be a literal string or another placeholder. The optional ",(0,s.jsx)(n.code,{children:"fmt"})," (",(0,s.jsx)(n.code,{children:"hex"})," or ",(0,s.jsx)(n.code,{children:"bech32m"}),") specifies how to interpret the resolved source string. Defaults to ",(0,s.jsx)(n.code,{children:"bech32m"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"$file(<path>)"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:'"$file(./payload.bin)"'})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Reads the raw binary content of a file. The value is a byte array."}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"$hex(<hex_string>)"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:'"$hex(deadbeef0123)"'})}),"\n",(0,s.jsx)(n.td,{align:"left",children:"Interprets a literal string as a hexadecimal byte sequence. The value is a byte array."}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:"$json(<path>#<path>[#<fmt>])"})}),"\n",(0,s.jsx)(n.td,{align:"left",children:(0,s.jsx)(n.code,{children:'"$json(./cfg.json#profile.id#hex)"'})}),"\n",(0,s.jsxs)(n.td,{align:"left",children:["Parses a JSON file and extracts a value using a dot-separated path. The path is a dot-separated sequence of keys used to extract a value from a nested JSON object (e.g., ",(0,s.jsx)(n.code,{children:"data.user.id"}),"). This simple pathing does not support array indexing or advanced query expressions. If the extracted value is a string and a ",(0,s.jsx)(n.code,{children:"fmt"})," (",(0,s.jsx)(n.code,{children:"hex"})," or ",(0,s.jsx)(n.code,{children:"bech32m"}),") is provided, it is decoded into a byte array. Otherwise, the raw JSON value (string, number) is used."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"text-to-binary-decoding",children:["Text-to-Binary Decoding",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#text-to-binary-decoding",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["For placeholders like ",(0,s.jsx)(n.code,{children:"$json"})," that produce string outputs, the ",(0,s.jsx)(n.code,{children:"#hex"})," and ",(0,s.jsx)(n.code,{children:"#bech32m"})," format specifiers can be used to decode the final string into a raw byte array. This is required when the instruction field is a ",(0,s.jsx)(n.code,{children:"vector"}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"8-general-schema-rules",children:["8. General Schema Rules",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-general-schema-rules",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"field-naming-and-case-sensitivity",children:["Field Naming and Case Sensitivity",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#field-naming-and-case-sensitivity",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["All field names defined in this specification are ",(0,s.jsx)(n.strong,{children:"case-sensitive"})," and ",(0,s.jsx)(n.strong,{children:"MUST"})," be written in ",(0,s.jsx)(n.code,{children:"camelCase"}),". An LTM parsing tool must reject any manifest that uses a different case or format (e.g., ",(0,s.jsx)(n.code,{children:"snake_case"})," or ",(0,s.jsx)(n.code,{children:"kebab-case"}),") for official field names."]}),"\n",(0,s.jsxs)(n.h4,{id:"comments",children:["Comments",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#comments",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["JSON does not natively support comments. To allow for inline documentation, any JSON object within an LTM file may include a field with the key ",(0,s.jsx)(n.code,{children:"comment"}),". An LTM tool ",(0,s.jsx)(n.strong,{children:"MUST"})," completely ignore this field and its value during processing."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "uleb": 5,\n  "comment": "Instruction ID 5 is for user registration."\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"9-data-type-handling",children:["9. Data Type Handling",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-data-type-handling",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Literals:"})," Values without placeholders are treated as literals (e.g., ",(0,s.jsx)(n.code,{children:"123"}),", ",(0,s.jsx)(n.code,{children:'"hello"'}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Large Integers:"})," The JSON specification allows for numbers of arbitrary precision. However, many standard parsers (like JavaScript's native ",(0,s.jsx)(n.code,{children:"JSON.parse()"}),") will truncate large integer values, leading to silent data corruption. Therefore, it is a strict requirement that any compliant LTM implementation ",(0,s.jsx)(n.strong,{children:"MUST"})," use a parser that preserves the full precision of all numeric literals, converting them to a ",(0,s.jsx)(n.code,{children:"BigInt"})," or an equivalent lossless type. While a compliant tool must handle unquoted large numbers safely, providing them as strings (e.g., ",(0,s.jsx)(n.code,{children:'"18446744073709551615"'}),") remains a recommended best practice to ensure maximum compatibility across different platforms and tools."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Programmable Use:"})," When used as a library, an LTM build tool should provide maximum flexibility by accepting direct JavaScript types for instruction fields. This includes ",(0,s.jsx)(n.code,{children:"Uint8Array"})," for vector types, ",(0,s.jsx)(n.code,{children:"BigInt"})," for large integer types (e.g., ",(0,s.jsx)(n.code,{children:"uint64"}),", ",(0,s.jsx)(n.code,{children:"sleb"}),"), and standard ",(0,s.jsx)(n.code,{children:"Number"})," for smaller integer and float types (e.g., ",(0,s.jsx)(n.code,{children:"uint32"}),", ",(0,s.jsx)(n.code,{children:"float64"}),"). The tool is responsible for validating that a provided ",(0,s.jsx)(n.code,{children:"Number"})," is within the valid and safe range for its target SCTP type."]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"full-example",children:["Full Example",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#full-example",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "comment": "This transaction registers a new user and transfers an initial credit.",\n  "sequence": 2,\n  "feePayer": "registrar",\n  "gasLimit": 500000,\n  "gasPrice": 10,\n  "outputFile": "./register-user.tx.bin",\n  "constants": {\n    "contract": "a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2",\n    "registrationId": 1,\n    "transferId": 2,\n    "recipient": "lea1qys33pduaxmjwsg329z2yotg5j222q8g2f53g6"\n  },\n  "signers": {\n    "auditor": "./keys/auditor.keyset.json",\n    "registrar": "./keys/registrar.keyset.json"\n  },\n  "invocations": [\n    {\n      "targetAddress": "$const(contract)",\n      "instructions": [\n        {\n          "uleb": "$const(registrationId)",\n          "comment": "Instruction ID 1 is for registering a new user."\n        },\n        { "vector": "$json(./user-data.json#profile.username)" },\n        { "uint64": "9876543210" },\n        { "vector": "$signer(registrar.address)" }\n      ]\n    },\n    {\n      "targetAddress": "$const(contract)",\n      "instructions": [\n        {\n          "uleb": "$const(transferId)",\n          "comment": "Instruction ID 2 is for transferring credits."\n        },\n        {\n          "uint8": "$addr($const(recipient))",\n          "comment": "The recipient is identified by their address, resolved to an index."\n        },\n        { "uint64": "1000", "comment": "Transfer 1000 credit units." }\n      ]\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"rationale",children:["Rationale",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rationale",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"The design of the LTM is guided by the principles of clarity, safety, and flexibility."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"JSON as a Base:"})," JSON is ubiquitous, human-readable, and supported by virtually all programming languages, making it an ideal foundation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declarative Approach:"})," By defining ",(0,s.jsx)(n.em,{children:"what"})," the transaction should contain rather than ",(0,s.jsx)(n.em,{children:"how"})," to build it, the manifest separates concerns. This simplifies the user's task and allows the underlying build tool to be optimized independently."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Placeholder System:"})," A simple, consistent placeholder syntax (",(0,s.jsx)(n.code,{children:"$source(...)"}),") provides powerful and explicit data sourcing capabilities. This avoids the need for complex templating languages while enabling composition from files and other data sources."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single-Key Instruction Objects:"})," Using ",(0,s.jsx)(n.code,{children:'{ "type": "value" }'})," for instructions is concise and less verbose than ",(0,s.jsx)(n.code,{children:'{ "type": "type", "value": "value" }'}),", making the manifest cleaner and easier to read."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"tooling-recommendations",children:["Tooling Recommendations",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tooling-recommendations",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"To improve the developer experience and provide better debugging capabilities, this specification recommends that a compliant LTM build tool implement the following features."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dry Run / Debug Mode:"})," A tool ",(0,s.jsx)(n.strong,{children:"SHOULD"}),' provide a "dry run" or "debug" flag (e.g., ',(0,s.jsx)(n.code,{children:"--resolve-only"}),"). When enabled, this mode would perform all placeholder resolution and validation steps and then output the fully resolved JSON manifest, with all placeholders replaced by their final values. It would stop before performing binary serialization or signing. This provides an invaluable mechanism for developers to inspect the final, resolved data and verify its correctness before creating the transaction."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"backwards-compatibility",children:["Backwards Compatibility",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#backwards-compatibility",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"The LEA Transaction Manifest is a new, additive standard for tooling and application-layer development. It does not propose any changes to the underlying transaction format defined in LIP-7 or any other core protocol rule. Therefore, it introduces no backwards compatibility issues."}),"\n",(0,s.jsxs)(n.h2,{id:"security-considerations",children:["Security Considerations",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#security-considerations",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:'A compliant LTM build tool MUST be designed with a "secure by default" philosophy, protecting users from potentially malicious manifests unless they explicitly opt into dangerous functionality.'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"File System Access:"})," The ",(0,s.jsx)(n.code,{children:"$file"})," and ",(0,s.jsx)(n.code,{children:"$json"})," placeholders can read from the file system. To prevent unauthorized access, a build tool ",(0,s.jsx)(n.strong,{children:"MUST"})," enforce the following rules by default:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All file paths MUST resolve to a location within the same directory as the manifest file, or a subdirectory thereof. Path traversal (",(0,s.jsx)(n.code,{children:"../"}),") is forbidden."]}),"\n",(0,s.jsx)(n.li,{children:"Symbolic links MUST NOT be followed."}),"\n",(0,s.jsxs)(n.li,{children:["Broader file system access should only be possible via an explicit flag (e.g., ",(0,s.jsx)(n.code,{children:"--enable-unsafe-filesystem-access"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Limits (Anti-DoS):"})," To prevent Denial-of-Service attacks, a build tool ",(0,s.jsx)(n.strong,{children:"MUST"})," enforce reasonable resource limits by default.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"File Size:"})," The maximum size for files read via ",(0,s.jsx)(n.code,{children:"$file"})," or ",(0,s.jsx)(n.code,{children:"$json"})," should be limited (e.g., 1 MB)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Nesting Depth:"})," The maximum nesting depth for placeholders should be limited (e.g., 3 levels)."]}),"\n",(0,s.jsxs)(n.li,{children:["These limits should only be removable with an explicit flag (e.g., ",(0,s.jsx)(n.code,{children:"--enable-unsafe-limits"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safe JSON Parsing:"})," Implementations of LTM parsers MUST use a library that can safely handle large integers (e.g., ",(0,s.jsx)(n.code,{children:"json-bigint"})," for Node.js) to prevent silent precision loss on 64-bit numbers. Parsers MUST also operate in a strict mode that rejects duplicate keys to prevent malicious or accidental parameter overrides."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Circular Dependencies:"})," A compliant LTM build tool ",(0,s.jsx)(n.strong,{children:"MUST"})," implement a mechanism to detect and reject manifests containing circular placeholder references (e.g., ",(0,s.jsx)(n.code,{children:'"$const(a)"'})," where ",(0,s.jsx)(n.code,{children:"a"})," references ",(0,s.jsx)(n.code,{children:'"$const(b)"'})," and ",(0,s.jsx)(n.code,{children:"b"})," references ",(0,s.jsx)(n.code,{children:'"$const(a)"'}),"). Failure to do so can result in non-terminating loops and denial-of-service vulnerabilities."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"copyright",children:["Copyright",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#copyright",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"This LIP is licensed under the MIT License."})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["lips%2FLIP-0010.md"]={toc:[{text:"Abstract",id:"abstract",depth:2},{text:"Motivation",id:"motivation",depth:2},{text:"Specification",id:"specification",depth:2},{text:"1. Top-Level Structure",id:"1-top-level-structure",depth:3},{text:"2. `signers` Object",id:"2-signers-object",depth:3},{text:"3. `constants` Object",id:"3-constants-object",depth:3},{text:"4. `invocations` Array",id:"4-invocations-array",depth:3},{text:"5. Address Vector and Signature Assembly",id:"5-address-vector-and-signature-assembly",depth:3},{text:"6. `instructions` Array",id:"6-instructions-array",depth:3},{text:"7. Placeholder Syntax for Dynamic Data",id:"7-placeholder-syntax-for-dynamic-data",depth:3},{text:"Text-to-Binary Decoding",id:"text-to-binary-decoding",depth:4},{text:"8. General Schema Rules",id:"8-general-schema-rules",depth:3},{text:"Field Naming and Case Sensitivity",id:"field-naming-and-case-sensitivity",depth:4},{text:"Comments",id:"comments",depth:4},{text:"9. Data Type Handling",id:"9-data-type-handling",depth:3},{text:"Full Example",id:"full-example",depth:3},{text:"Rationale",id:"rationale",depth:2},{text:"Tooling Recommendations",id:"tooling-recommendations",depth:2},{text:"Backwards Compatibility",id:"backwards-compatibility",depth:2},{text:"Security Considerations",id:"security-considerations",depth:2},{text:"Copyright",id:"copyright",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);