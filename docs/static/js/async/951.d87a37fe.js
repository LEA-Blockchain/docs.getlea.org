"use strict";(self.webpackChunkrspress=self.webpackChunkrspress||[]).push([["951"],{503:function(e,n,i){i.r(n),i.d(n,{default:()=>c});var s=i(5893),r=i(65);function t(e){let n=Object.assign({ul:"ul",li:"li",strong:"strong",h2:"h2",a:"a",p:"p",br:"br",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",code:"code",hr:"hr",ol:"ol"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"LIP: 7"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Layer: Application"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Title: Genesis Transaction Decoder Format"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Author: Allwin Ketnawang"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Created: 2025-07-07"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Requires: 6"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Status: Draft"})}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"abstract",children:["Abstract",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#abstract",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["This LIP defines the official, standardized binary layout interpreted by the Genesis LEA Transaction Decoder.",(0,s.jsx)(n.br,{}),"\n","As the first canonical decoder in the LEA model, it is based on the Simple Compact Transaction Protocol (SCTP) primitives introduced in ",(0,s.jsx)(n.a,{href:"/LIP-6",children:"LIP-6"}),". The format follows a flexible, invocation-based structure, including a unified address vector, gas configuration, a sequence of invocation instructions, and a dual-signature scheme (Ed25519 and SPHINCS-256s)."]}),"\n",(0,s.jsxs)(n.h2,{id:"motivation",children:["Motivation",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#motivation",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["While ",(0,s.jsx)(n.a,{href:"/LIP-6",children:"LIP-6"}),' defines the low-level data primitives for encoding data, it does not define the high-level structure of a transaction (the "grammar"). A standard transaction format is essential for all network participants to interpret, validate, and process transactions in a uniform way. This proposal provides that standard, detailing the exact order, type, and meaning of each component within a transaction. It also specifies the precise method for hashing and signing transactions to ensure cryptographic integrity.']}),"\n",(0,s.jsxs)(n.h2,{id:"specification",children:["Specification",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#specification",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["All LEA transactions MUST be serialized according to the following structure, using the SCTP encoding types defined in ",(0,s.jsx)(n.a,{href:"/LIP-6",children:"LIP-6"}),". The transaction's total decoded size MUST NOT exceed 1MB."]}),"\n",(0,s.jsxs)(n.h3,{id:"core-type-system",children:["Core Type System",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#core-type-system",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"The transaction format utilizes a specific subset of the SCTP types:"}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"SCTP Type ID"}),"\n",(0,s.jsx)(n.th,{children:"Name"}),"\n",(0,s.jsx)(n.th,{children:"Description"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"8"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ULEB128"})}),"\n",(0,s.jsx)(n.td,{children:"Unsigned variable-length integer"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"13"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VECTOR"})}),"\n",(0,s.jsx)(n.td,{children:"Raw byte array with a length prefix"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"15"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"EOF"})}),"\n",(0,s.jsxs)(n.td,{children:["End-of-transaction marker (literal byte: ",(0,s.jsx)(n.code,{children:"0x0F"}),")"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"lea-transaction-format-as-interpreted-by-genesis-decoder",children:["LEA Transaction Format (as interpreted by Genesis Decoder)",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#lea-transaction-format-as-interpreted-by-genesis-decoder",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["A transaction is a sequence of core fields followed by a variable number of ",(0,s.jsx)(n.code,{children:"Invocation"})," blocks and ",(0,s.jsx)(n.code,{children:"SignaturePair"})," blocks."]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"Field"}),"\n",(0,s.jsx)(n.th,{children:"Type"}),"\n",(0,s.jsx)(n.th,{children:"Description"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"version"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ULEB128"})}),"\n",(0,s.jsxs)(n.td,{children:["Transaction format version. The value MUST be ",(0,s.jsx)(n.code,{children:"1"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"sequence"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ULEB128"})}),"\n",(0,s.jsx)(n.td,{children:"Sender's nonce or sequence number"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"addresses"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VECTOR"})}),"\n",(0,s.jsx)(n.td,{children:"32-byte addresses; signers first, fee payer first"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"gasLimit"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ULEB128"})}),"\n",(0,s.jsx)(n.td,{children:"Max gas units allowed"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"gasPrice"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ULEB128"})}),"\n",(0,s.jsx)(n.td,{children:"Price per gas unit"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"invocations"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Invocation[]"})}),"\n",(0,s.jsx)(n.td,{children:"One or more invocation instructions"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"signatures"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SignaturePair[]"})}),"\n",(0,s.jsx)(n.td,{children:"One signature pair per signer"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"EOF"})}),"\n",(0,s.jsxs)(n.td,{children:["Byte (",(0,s.jsx)(n.code,{children:"0x0F"}),")"]}),"\n",(0,s.jsx)(n.td,{children:"End-of-transaction marker (literal byte)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"invocation-block",children:["Invocation Block",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#invocation-block",children:"#"})]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"Field"}),"\n",(0,s.jsx)(n.th,{children:"Type"}),"\n",(0,s.jsx)(n.th,{children:"Description"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"targetIndex"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ULEB128"})}),"\n",(0,s.jsxs)(n.td,{children:["Index into the ",(0,s.jsx)(n.code,{children:"addresses"})," vector (0-based)"]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"instructions"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VECTOR"})}),"\n",(0,s.jsx)(n.td,{children:"Instruction bytecode intended for the target address"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"signaturepair-block",children:["SignaturePair Block",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#signaturepair-block",children:"#"})]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"Field"}),"\n",(0,s.jsx)(n.th,{children:"Type"}),"\n",(0,s.jsx)(n.th,{children:"Description"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ed25519Signature"})}),"\n",(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"VECTOR"})," (64 bytes)"]}),"\n",(0,s.jsx)(n.td,{children:"Ed25519 signature over the hash"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"sphincs256sSignature"})}),"\n",(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"VECTOR"})," (29792 bytes)"]}),"\n",(0,s.jsx)(n.td,{children:"SPHINCS-256s signature for PQC security"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"notation-key",children:["Notation Key",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#notation-key",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[]"})," = Repeating block (zero or more)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"VECTOR"})," = Length-prefixed byte array"]}),"\n",(0,s.jsx)(n.li,{children:"All field names are case-sensitive and must follow the specified order"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"field-constraints-and-rules",children:["Field Constraints and Rules",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#field-constraints-and-rules",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Addresses (",(0,s.jsx)(n.code,{children:"addresses"}),"):"]})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["This field is a single SCTP ",(0,s.jsx)(n.code,{children:"VECTOR"})," containing all 32-byte addresses involved in the transaction."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"addresses"})," vector MUST be assembled using a deterministic, three-tiered sorting algorithm to ensure a single, canonical representation:\na.  ",(0,s.jsx)(n.strong,{children:"Group 1 (Fee Payer):"})," The address of the fee payer MUST be the ",(0,s.jsx)(n.strong,{children:"first"})," address in the vector (index 0).\nb.  ",(0,s.jsx)(n.strong,{children:"Group 2 (Other Signers):"})," The addresses of all other signers (i.e., the signers from index 1 to N-1) MUST be sorted amongst themselves based on their 32-byte binary lexicographical value. These are appended to the vector immediately after the fee payer.\nc.  ",(0,s.jsx)(n.strong,{children:"Group 3 (Non-Signer Addresses):"})," All remaining unique, non-signer addresses MUST also be sorted amongst themselves based on their 32-byte binary lexicographical value. These are appended last."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"addresses"})," vector MUST NOT contain duplicate entries."]}),"\n",(0,s.jsx)(n.li,{children:"The total byte length of the vector MUST be a multiple of 32."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Invocations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The transaction contains one or more ",(0,s.jsx)(n.code,{children:"Invocation"})," blocks."]}),"\n",(0,s.jsxs)(n.li,{children:["Each ",(0,s.jsx)(n.code,{children:"Invocation"})," consists of a ",(0,s.jsx)(n.code,{children:"targetIndex"})," (",(0,s.jsx)(n.code,{children:"ULEB128"}),") followed by an ",(0,s.jsx)(n.code,{children:"instructions"})," field (",(0,s.jsx)(n.code,{children:"VECTOR"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"targetIndex"})," MUST be a valid, 0-based index into the ",(0,s.jsx)(n.code,{children:"addresses"})," vector."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"instructions"})," field contains the application-specific instruction bytecode to be executed in the context of the targeted address."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signature Set:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The number of ",(0,s.jsx)(n.code,{children:"SignaturePair"})," blocks implicitly defines the number of signed addresses. If there are ",(0,s.jsx)(n.code,{children:"N"})," signature pairs, then the first ",(0,s.jsx)(n.code,{children:"N"})," addresses in the ",(0,s.jsx)(n.code,{children:"addresses"})," vector are considered signers."]}),"\n",(0,s.jsxs)(n.li,{children:["Each ",(0,s.jsx)(n.code,{children:"SignaturePair"})," corresponds one-to-one with the signers in the ",(0,s.jsx)(n.code,{children:"addresses"})," vector by index."]}),"\n",(0,s.jsxs)(n.li,{children:["Each ",(0,s.jsx)(n.code,{children:"SignaturePair"})," contains two ",(0,s.jsx)(n.code,{children:"VECTOR"}),"s:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ed25519Signature"}),": A 64-byte Ed25519 signature."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sphincs256sSignature"}),": A 29,792-byte SPHINCS-256s signature."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Termination:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Every valid transaction MUST end with a single EOF byte (",(0,s.jsx)(n.code,{children:"0x0F"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"No other data is permitted after the EOF marker."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"hashing-and-signing-protocol",children:["Hashing and Signing Protocol",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hashing-and-signing-protocol",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hashing:"})," The transaction hash is the ",(0,s.jsx)(n.code,{children:"BLAKE3"})," digest of the byte stream from the ",(0,s.jsx)(n.code,{children:"version"})," field up to and including the final byte of the last ",(0,s.jsx)(n.code,{children:"Invocation"})," block's ",(0,s.jsx)(n.code,{children:"instructions"})," field. The ",(0,s.jsx)(n.code,{children:"SignatureSet"})," and the final EOF marker are ",(0,s.jsx)(n.strong,{children:"excluded"})," from the hash."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Signing:"})," For every signing address, a corresponding ",(0,s.jsx)(n.code,{children:"SignaturePair"})," must be provided. The Ed25519 and SPHINCS-256s signatures are calculated over the transaction hash.",(0,s.jsx)(n.br,{}),"\n","Signature verification MUST be performed in index order, matching each ",(0,s.jsx)(n.code,{children:"SignaturePair"})," to the corresponding address in the ",(0,s.jsx)(n.code,{children:"addresses"})," vector, starting from index ",(0,s.jsx)(n.code,{children:"0"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"rationale",children:["Rationale",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rationale",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexible Invocations:"})," The repeating block structure for invocations allows for complex transactions that can interact with multiple programs in a single atomic unit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implicit Signer Count:"})," Deriving the number of signers from the number of ",(0,s.jsx)(n.code,{children:"SignaturePair"})," blocks simplifies parsing and removes the need for a separate field to declare the signer count."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unified Address List:"})," A single ",(0,s.jsx)(n.code,{children:"addresses"})," vector simplifies address management and indexing for invocations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dual Signatures:"})," Requiring both Ed25519 and SPHINCS-256s (a PQC algorithm) signatures provides both high performance for standard validation and long-term security against quantum attacks."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SCTP Base:"})," Building on ",(0,s.jsx)(n.a,{href:"/LIP-6",children:"LIP-6"}),", this ensures that the low-level encoding is consistent with the rest of the protocol."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"backwards-compatibility",children:["Backwards Compatibility",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#backwards-compatibility",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"This LIP defines a new, foundational application-layer standard. It does not replace a previously defined transaction format LIP. As such, it does not introduce a backwards compatibility break in the LIP process, but its adoption is a mandatory and breaking change for any client or node software wishing to interact with the LEA network, in conjunction with the adoption of LIP-6."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"security-considerations",children:["Security Considerations",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#security-considerations",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hashing Integrity:"})," Validators MUST strictly adhere to the specified hashing protocol. Including any part of the ",(0,s.jsx)(n.code,{children:"SignatureSet"})," in the hash would invalidate all signatures."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Signature Verification:"})," For each ",(0,s.jsx)(n.code,{children:"SignaturePair"}),", both the Ed25519 and SPHINCS-256s signatures must be successfully verified against the transaction hash using the public key of the corresponding signing address. A failure in either verification invalidates the transaction."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Index-out-of-Bounds:"})," Parsers MUST validate that each ",(0,s.jsx)(n.code,{children:"targetIndex"})," in an invocation is a valid index within the ",(0,s.jsx)(n.code,{children:"addresses"})," vector. An invalid index must cause the transaction to be rejected."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Vector Length Validation:"})," Parsers MUST validate that the ",(0,s.jsx)(n.code,{children:"addresses"})," vector length is a multiple of 32 and that the signature vectors have the correct fixed lengths (64 and 29792). Failure to do so could lead to buffer overflows or incorrect data interpretation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fee Payer:"})," The first entry in the ",(0,s.jsx)(n.code,{children:"addresses"})," vector is the fee payer. Logic for deducting fees must correctly and exclusively identify this address."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"copyright",children:["Copyright",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#copyright",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["This LIP is licensed under the MIT License, in alignment with the main ",(0,s.jsx)(n.a,{href:"https://getlea.org",target:"_blank",rel:"noopener noreferrer",children:"LEA Project"})," License."]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["lips%2FLIP-0007.md"]={toc:[{text:"Abstract",id:"abstract",depth:2},{text:"Motivation",id:"motivation",depth:2},{text:"Specification",id:"specification",depth:2},{text:"Core Type System",id:"core-type-system",depth:3},{text:"LEA Transaction Format (as interpreted by Genesis Decoder)",id:"lea-transaction-format-as-interpreted-by-genesis-decoder",depth:3},{text:"Invocation Block",id:"invocation-block",depth:3},{text:"SignaturePair Block",id:"signaturepair-block",depth:3},{text:"Notation Key",id:"notation-key",depth:3},{text:"Field Constraints and Rules",id:"field-constraints-and-rules",depth:3},{text:"Hashing and Signing Protocol",id:"hashing-and-signing-protocol",depth:3},{text:"Rationale",id:"rationale",depth:2},{text:"Backwards Compatibility",id:"backwards-compatibility",depth:2},{text:"Security Considerations",id:"security-considerations",depth:2},{text:"Copyright",id:"copyright",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);