"use strict";(self.webpackChunkrspress=self.webpackChunkrspress||[]).push([["450"],{926:function(e,i,t){t.r(i),t.d(i,{default:()=>a});var n=t(5893),s=t(65);function r(e){let i=Object.assign({ul:"ul",li:"li",strong:"strong",h2:"h2",a:"a",p:"p",code:"code",ol:"ol"},(0,s.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:"LIP: 9"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:"Layer: Consensus"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:"Title: Programmable Transaction Format"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:"Author: Allwin Ketnawang"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:"Created: 2025-07-12"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.strong,{children:"Status: Draft"})}),"\n"]}),"\n",(0,n.jsxs)(i.h2,{id:"abstract",children:["Abstract",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#abstract",children:"#"})]}),"\n",(0,n.jsxs)(i.p,{children:["This LIP proposes a universal transaction format for the LEA protocol. The format consists of a minimal, two-part structure: a ",(0,n.jsx)(i.code,{children:"DecoderID"})," and a ",(0,n.jsx)(i.code,{children:"Payload"}),". The ",(0,n.jsx)(i.code,{children:"DecoderID"})," is a 32-byte identifier for an on-chain contract responsible for interpreting the transaction. The ",(0,n.jsx)(i.code,{children:"Payload"})," is an opaque byte stream passed to this contract. This design delegates all transaction validation, serialization, and execution logic to the contract layer, making the base protocol itself simpler and more extensible."]}),"\n",(0,n.jsxs)(i.h2,{id:"motivation",children:["Motivation",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#motivation",children:"#"})]}),"\n",(0,n.jsx)(i.p,{children:"Traditional blockchain protocols enforce a single, rigid transaction structure. This creates significant friction when introducing new features, such as novel signature schemes, privacy-preserving technologies, or account abstraction logic. Implementing such upgrades typically requires a network-wide consensus change (hard fork), which is a slow, contentious, and complex process."}),"\n",(0,n.jsx)(i.p,{children:"The motivation for this proposal is to create a flexible and future-proof foundation for the protocol. By abstracting transaction interpretation away from the base consensus rules, the network can adopt new functionalities dynamically, without requiring core protocol modifications. This shifts the responsibility for innovation to the execution layer, allowing for faster, permissionless evolution."}),"\n",(0,n.jsxs)(i.h2,{id:"specification",children:["Specification",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#specification",children:"#"})]}),"\n",(0,n.jsx)(i.p,{children:'The base protocol shall recognize a single transaction structure, referred to as the "Transaction Envelope."'}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"Transaction Envelope Definition:"}),"\nThe Transaction Envelope is the raw byte array submitted to the network for processing. It is composed of two distinct fields:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"DecoderID"}),' [bytes 32]: The first 32 bytes of the envelope. This field contains the address of a smart contract, hereafter referred to as the "Decoder."']}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"Payload"})," [bytes N]: All bytes of the envelope following the ",(0,n.jsx)(i.code,{children:"DecoderID"}),". The protocol treats this field as an opaque byte stream."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"Base Protocol Execution Rule:"}),"\nThe consensus layer will enforce a single, immutable rule for initiating transaction processing:"]}),"\n",(0,n.jsxs)(i.p,{children:["a. Upon receiving a Transaction Envelope, the node reads the first 32 bytes to identify the ",(0,n.jsx)(i.code,{children:"DecoderID"}),".\nb. The node invokes the contract located at the ",(0,n.jsx)(i.code,{children:"DecoderID"})," address.\nc. The node passes the ",(0,n.jsx)(i.code,{children:"Payload"})," to the Decoder contract for all subsequent processing."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"Decoder Responsibilities:"}),"\nThe Decoder contract is responsible for all logic related to the transaction, including, but not limited to:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Parsing the ",(0,n.jsx)(i.code,{children:"Payload"}),"."]}),"\n",(0,n.jsx)(i.li,{children:"Validating signatures and authorizing the transaction."}),"\n",(0,n.jsx)(i.li,{children:"Implementing replay protection (e.g., via a nonce)."}),"\n",(0,n.jsx)(i.li,{children:"Defining and processing fee payments."}),"\n",(0,n.jsx)(i.li,{children:"Executing the state transition."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.h2,{id:"rationale",children:["Rationale",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#rationale",children:"#"})]}),"\n",(0,n.jsx)(i.p,{children:"The design is based on the principle of a minimal, robust core protocol with maximal flexibility at the edges."}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Forward Compatibility:"})," This is the primary rationale. New cryptographic standards (e.g., post-quantum signatures) or transaction features (e.g., calldata compression, ZK-proof verification) can be introduced by deploying a new Decoder contract. This avoids the need for hard forks for a wide class of upgrades."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Native Account Abstraction:"})," This model provides account abstraction at the protocol's most fundamental level. The logic for what constitutes a valid transaction (e.g., multi-sig, social recovery, fee payment in arbitrary tokens) is not defined by the protocol but by the Decoder, which is chosen by the user or wallet."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Architectural Simplicity:"})," By delegating complexity to the execution layer, the consensus engine is simplified significantly. Its sole responsibility is to dispatch the payload to the correct interpreter. This reduces the surface area for potential consensus-level bugs. This layered architecture is analogous to the Internet Protocol (IP), where the core network layer is responsible for routing packets, while higher-level protocols (TCP, HTTP) handle interpretation and structure."]}),"\n"]}),"\n",(0,n.jsxs)(i.h2,{id:"backwards-compatibility",children:["Backwards Compatibility",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#backwards-compatibility",children:"#"})]}),"\n",(0,n.jsx)(i.p,{children:"This LIP defines the foundational transaction format for the LEA protocol. As such, it does not have backwards compatibility considerations with a prior state. It establishes the framework upon which all future transaction types will be built."}),"\n",(0,n.jsxs)(i.h2,{id:"security-considerations",children:["Security Considerations",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#security-considerations",children:"#"})]}),"\n",(0,n.jsx)(i.p,{children:"The security model is shifted from the protocol to the execution layer."}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Decoder Security:"})," The integrity and security of any given transaction are entirely dependent on the implementation of its specified Decoder contract. Users must trust the Decoders they use. A buggy or malicious Decoder could result in a permanent loss of funds."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Gas Metering:"})," To prevent Denial-of-Service attacks from computationally intensive or non-terminating Decoders, their execution must be strictly metered (i.e., via a gas mechanism)."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Replay Protection:"})," The base protocol does not provide replay protection. Each Decoder must implement its own nonce or other replay prevention mechanism. Failure to do so would make transactions vulnerable to replay attacks."]}),"\n"]}),"\n",(0,n.jsxs)(i.h2,{id:"copyright",children:["Copyright",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#copyright",children:"#"})]}),"\n",(0,n.jsx)(i.p,{children:"This LIP is licensed under the MIT License."})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:i}=Object.assign({},(0,s.ah)(),e.components);return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(r,{...e})}):r(e)}let a=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["lips%2FLIP-0009.md"]={toc:[{text:"Abstract",id:"abstract",depth:2},{text:"Motivation",id:"motivation",depth:2},{text:"Specification",id:"specification",depth:2},{text:"Rationale",id:"rationale",depth:2},{text:"Backwards Compatibility",id:"backwards-compatibility",depth:2},{text:"Security Considerations",id:"security-considerations",depth:2},{text:"Copyright",id:"copyright",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);