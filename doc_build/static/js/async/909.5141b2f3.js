"use strict";(self.webpackChunkrspress=self.webpackChunkrspress||[]).push([["909"],{1999:function(e,n,i){i.r(n),i.d(n,{default:()=>l});var t=i(5893),s=i(65);function r(e){let n=Object.assign({ul:"ul",li:"li",strong:"strong",h2:"h2",a:"a",p:"p",h3:"h3",h4:"h4",code:"code",hr:"hr",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",em:"em"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"LIP: 6"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Layer: Core Encoding"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Title: Replace Core Transaction Encoding (CTE) with Simple Compact Transaction Protocol (SCTP)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Author: Allwin Ketnawang"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Created: 2025-07-07"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Replaces: 1, 2, 4, 5"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Status: Proposed"})}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"abstract",children:["Abstract",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#abstract",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:'This LIP officially deprecates the Core Transaction Encoding (CTE) and all associated improvement proposals (LIPs 1, 2, 4, 5). It is replaced by a new, streamlined encoding standard known as the "Simple Compact Transaction Protocol" (SCTP). This proposal formalizes the transition and contains the complete technical specification for SCTP, marking a fundamental shift in the project\'s approach to data serialization.'}),"\n",(0,t.jsxs)(n.h2,{id:"motivation",children:["Motivation",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#motivation",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"The Core Transaction Encoding (CTE) was becoming increasingly complex. A series of proposed extensions (LIPs 1, 2, 4, 5) highlighted that incremental patches were leading to a fragmented and overly complicated design. Rather than continuing to amend the original specification, a decision was made to develop a new encoding from the ground up. The Simple Compact Transaction Protocol (SCTP) was designed to be simpler, more performant, and more extensible than CTE. This LIP serves to formally ratify the switch, providing a clean break from the legacy system and establishing a more robust foundation for future development."}),"\n",(0,t.jsxs)(n.h2,{id:"specification",children:["Specification",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#specification",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"The Core Transaction Encoding (CTE) is deprecated. All LEA-compliant systems will adopt the Simple Compact Transaction Protocol (SCTP) for all transaction encoding purposes."}),"\n",(0,t.jsx)(n.p,{children:"The following is the complete technical specification for SCTP."}),"\n",(0,t.jsxs)(n.h3,{id:"overview",children:["Overview",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#overview",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["A SCTP stream is a sequence of typed data fields. Each field is prefixed with a 1-byte header that defines its type and provides metadata. All multi-byte integer and floating-point values are encoded in ",(0,t.jsx)(n.strong,{children:"little-endian"})," byte order."]}),"\n",(0,t.jsxs)(n.h4,{id:"header-byte",children:["Header Byte",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#header-byte",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"Every data field begins with a header byte, structured as follows:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"MMMM TTTT"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"TTTT"})," (lower 4 bits):"]})," The ",(0,t.jsx)(n.strong,{children:"Type Identifier"}),". This specifies the data type of the field."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"MMMM"})," (upper 4 bits):"]})," ",(0,t.jsx)(n.strong,{children:"Metadata"}),". Its meaning depends on the ",(0,t.jsx)(n.code,{children:"TTTT"})," value."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"type-identifiers",children:["Type Identifiers",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#type-identifiers",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"TTTT"})," bits map to the following data types."]}),"\n",(0,t.jsxs)(n.table,{children:["\n",(0,t.jsxs)(n.thead,{children:["\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.th,{align:"left",children:"Type ID"}),"\n",(0,t.jsx)(n.th,{align:"left",children:"Name"}),"\n",(0,t.jsx)(n.th,{align:"left",children:"Description"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.tbody,{children:["\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"0"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"INT8"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Signed 8-bit integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"1"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"UINT8"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Unsigned 8-bit integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"2"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"INT16"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Signed 16-bit integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"3"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"UINT16"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Unsigned 16-bit integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"4"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"INT32"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Signed 32-bit integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"5"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"UINT32"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Unsigned 32-bit integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"6"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"INT64"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Signed 64-bit integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"7"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"UINT64"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Unsigned 64-bit integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"8"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"ULEB128"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Unsigned LEB128-encoded integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"9"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"SLEB128"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"Signed LEB128-encoded integer."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"10"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"FLOAT32"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"32-bit floating-point number."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"11"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"FLOAT64"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"64-bit floating-point number."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"12"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"SHORT"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"A small integer (0-15) in a single byte."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"13"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"VECTOR"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"A generic byte array."}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"14"}),"\n",(0,t.jsx)(n.td,{align:"left"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.em,{children:"(Reserved for future use)"})}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{align:"left",children:"15"}),"\n",(0,t.jsx)(n.td,{align:"left",children:(0,t.jsx)(n.code,{children:"EOF"})}),"\n",(0,t.jsx)(n.td,{align:"left",children:"End of Stream marker."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"type-encoding-details",children:["Type Encoding Details",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#type-encoding-details",children:"#"})]}),"\n",(0,t.jsxs)(n.h4,{id:"fixed-size--variable-size-numerics",children:["Fixed-Size & Variable-Size Numerics",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#fixed-size--variable-size-numerics",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Types:"})," ",(0,t.jsx)(n.code,{children:"INT8"})," - ",(0,t.jsx)(n.code,{children:"UINT64"}),", ",(0,t.jsx)(n.code,{children:"ULEB128"}),", ",(0,t.jsx)(n.code,{children:"SLEB128"}),", ",(0,t.jsx)(n.code,{children:"FLOAT32"}),", ",(0,t.jsx)(n.code,{children:"FLOAT64"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encoding:"})," The header's ",(0,t.jsx)(n.code,{children:"MMMM"})," bits are unused and should be ",(0,t.jsx)(n.code,{children:"0000"}),". The binary data of the specified type immediately follows the header byte."]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"short",children:[(0,t.jsx)(n.code,{children:"SHORT"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#short",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Encodes a small, unsigned integer value from 0 to 15."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encoding:"})," The entire field is a ",(0,t.jsx)(n.strong,{children:"single byte"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"TTTT"})," bits identify the type as ",(0,t.jsx)(n.code,{children:"SHORT"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"MMMM"})," bits contain the actual integer value."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"vector",children:[(0,t.jsx)(n.code,{children:"VECTOR"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vector",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Encodes a variable-length array of bytes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Encoding:"})," The ",(0,t.jsx)(n.code,{children:"MMMM"})," bits in the header determine how the size is encoded."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Case 1: Small Vector (0-14 bytes)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"MMMM"})," bits hold the length of the vector (",(0,t.jsx)(n.code,{children:"0000"})," to ",(0,t.jsx)(n.code,{children:"1110"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"The vector's byte data immediately follows the header."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Case 2: Large Vector (>= 15 bytes)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"MMMM"})," bits are set to ",(0,t.jsx)(n.code,{children:"1111"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["This signals that a ",(0,t.jsx)(n.strong,{children:"ULEB128-encoded integer"})," representing the vector's true length follows the header."]}),"\n",(0,t.jsx)(n.li,{children:"The vector's byte data follows the ULEB128 length."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"eof",children:[(0,t.jsx)(n.code,{children:"EOF"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#eof",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Marks the end of the data stream."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encoding:"})," A single byte where the ",(0,t.jsx)(n.code,{children:"TTTT"})," bits are ",(0,t.jsx)(n.code,{children:"1111"}),". The ",(0,t.jsx)(n.code,{children:"MMMM"})," bits should be ",(0,t.jsx)(n.code,{children:"0000"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"rationale",children:["Rationale",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rationale",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"A new, unified encoding standard is preferable to a heavily patched legacy system. By replacing CTE with SCTP, we avoid the accumulated complexity of multiple LIPs and introduce a more coherent design. Embedding the specification directly into the LIP ensures that the proposal and its technical details are reviewed and approved as a single, atomic unit."}),"\n",(0,t.jsxs)(n.h2,{id:"backwards-compatibility",children:["Backwards Compatibility",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#backwards-compatibility",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["This is a ",(0,t.jsx)(n.strong,{children:"fundamental breaking change"}),'. Transactions encoded using the legacy CTE format are not compatible with the new SCTP standard and will be invalid. This change necessitates a coordinated network upgrade. A specific block height or "flag day" will be designated for the switchover from CTE to SCTP. All node operators and developers must upgrade their software to a version that supports SCTP before this activation point to remain on the network.']}),"\n",(0,t.jsxs)(n.h2,{id:"security-considerations",children:["Security Considerations",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#security-considerations",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["The security of the LEA protocol now depends entirely on the correctness and robustness of the SCTP specification and its implementations. Implementers must be diligent in creating parsers that are robust against malformed or malicious data to prevent potential vulnerabilities, especially when decoding variable-length structures like ",(0,t.jsx)(n.code,{children:"VECTOR"}),", ",(0,t.jsx)(n.code,{children:"ULEB128"}),", and ",(0,t.jsx)(n.code,{children:"SLEB128"}),". The deprecation of CTE removes any security concerns associated with its previous complexity and patches."]}),"\n",(0,t.jsxs)(n.h2,{id:"copyright",children:["Copyright",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#copyright",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["This LIP is licensed under the MIT License, in alignment with the main ",(0,t.jsx)(n.a,{href:"https://getlea.org",target:"_blank",rel:"noopener noreferrer",children:"LEA Project"})," License."]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["lips%2FLIP-0006.md"]={toc:[{text:"Abstract",id:"abstract",depth:2},{text:"Motivation",id:"motivation",depth:2},{text:"Specification",id:"specification",depth:2},{text:"Overview",id:"overview",depth:3},{text:"Header Byte",id:"header-byte",depth:4},{text:"Type Identifiers",id:"type-identifiers",depth:3},{text:"Type Encoding Details",id:"type-encoding-details",depth:3},{text:"Fixed-Size & Variable-Size Numerics",id:"fixed-size--variable-size-numerics",depth:4},{text:"`SHORT`",id:"short",depth:4},{text:"`VECTOR`",id:"vector",depth:4},{text:"`EOF`",id:"eof",depth:4},{text:"Rationale",id:"rationale",depth:2},{text:"Backwards Compatibility",id:"backwards-compatibility",depth:2},{text:"Security Considerations",id:"security-considerations",depth:2},{text:"Copyright",id:"copyright",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);